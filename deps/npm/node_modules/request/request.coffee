filterForNonReserved = (reserved, options) ->
  
  # Filter out properties that are not reserved.
  # Reserved values are passed in at call site.
  object = {}
  for i of options
    notReserved = (reserved.indexOf(i) is -1)
    object[i] = options[i]  if notReserved
  object
filterOutReservedFunctions = (reserved, options) ->
  
  # Filter out properties that are functions and are reserved.
  # Reserved values are passed in at call site.
  object = {}
  for i of options
    isReserved = (reserved.indexOf(i) isnt -1)
    isFunction = (typeof options[i] is "function")
    object[i] = options[i]  unless isReserved and isFunction
  object
constructProxyHost = (uriObject) ->
  port = uriObject.portA
  protocol = uriObject.protocol
  proxyHost = uriObject.hostname + ":"
  if port
    proxyHost += port
  else if protocol is "https:"
    proxyHost += "443"
  else
    proxyHost += "80"
  proxyHost
constructProxyHeaderWhiteList = (headers, proxyHeaderWhiteList) ->
  Object.keys(headers).filter((header) ->
    proxyHeaderWhiteList.indexOf(header.toLowerCase()) isnt -1
  ).reduce ((set, header) ->
    set[header] = headers[header]
    set
  ), {}
construcTunnelOptions = (request) ->
  proxy = request.proxy
  proxyHeaders = request.proxyHeaders
  proxyAuth = undefined
  proxyAuth = proxy.auth  if proxy.auth
  proxyHeaders["Proxy-Authorization"] = request.proxyAuthorization  if not proxy.auth and request.proxyAuthorization
  tunnelOptions =
    proxy:
      host: proxy.hostname
      port: +proxy.port
      proxyAuth: proxyAuth
      headers: proxyHeaders

    rejectUnauthorized: request.rejectUnauthorized
    headers: request.headers
    ca: request.ca
    cert: request.cert
    key: request.key

  tunnelOptions
constructTunnelFnName = (uri, proxy) ->
  uriProtocol = ((if uri.protocol is "https:" then "https" else "http"))
  proxyProtocol = ((if proxy.protocol is "https:" then "Https" else "Http"))
  [
    uriProtocol
    proxyProtocol
  ].join "Over"
getTunnelFn = (request) ->
  uri = request.uri
  proxy = request.proxy
  tunnelFnName = constructTunnelFnName(uri, proxy)
  tunnel[tunnelFnName]

# Decide the proper request proxy to use based on the request URI object and the
# environmental variables (NO_PROXY, HTTP_PROXY, etc.)
getProxyFromURI = (uri) ->
  
  # respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)
  noProxy = process.env.NO_PROXY or process.env.no_proxy or null
  
  # easy case first - if NO_PROXY is '*'
  return null  if noProxy is "*"
  
  # otherwise, parse the noProxy value to see if it applies to the URL
  if noProxy isnt null
    noProxyItem = undefined
    hostname = undefined
    port = undefined
    noProxyItemParts = undefined
    noProxyHost = undefined
    noProxyPort = undefined
    noProxyList = undefined
    
    # canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
    hostname = uri.hostname.replace(/^\.*/, ".").toLowerCase()
    noProxyList = noProxy.split(",")
    i = 0
    len = noProxyList.length

    while i < len
      noProxyItem = noProxyList[i].trim().toLowerCase()
      
      # no_proxy can be granular at the port level, which complicates things a bit.
      if noProxyItem.indexOf(":") > -1
        noProxyItemParts = noProxyItem.split(":", 2)
        noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".")
        noProxyPort = noProxyItemParts[1]
        port = uri.port or ((if uri.protocol is "https:" then "443" else "80"))
        
        # we've found a match - ports are same and host ends with no_proxy entry.
        return null  if port is noProxyPort and hostname.indexOf(noProxyHost) is hostname.length - noProxyHost.length
      else
        noProxyItem = noProxyItem.replace(/^\.*/, ".")
        return null  if hostname.indexOf(noProxyItem) is hostname.length - noProxyItem.length
      i++
  
  # check for HTTP(S)_PROXY environment variables
  if uri.protocol is "http:"
    return process.env.HTTP_PROXY or process.env.http_proxy or null
  else return process.env.HTTPS_PROXY or process.env.https_proxy or process.env.HTTP_PROXY or process.env.http_proxy or null  if uri.protocol is "https:"
  
  # return null if all else fails (What uri protocol are you using then?)
  null

# Function for properly handling a connection error
connectionErrorHandler = (error) ->
  socket = this
  if socket.res
    if socket.res.request
      socket.res.request.emit "error", error
    else
      socket.res.emit "error", error
  else
    socket._httpMessage.emit "error", error
  return

# Return a simpler request object to allow serialization
requestToJSON = ->
  self = this
  uri: self.uri
  method: self.method
  headers: self.headers

# Return a simpler response object to allow serialization
responseToJSON = ->
  self = this
  statusCode: self.statusCode
  body: self.body
  headers: self.headers
  request: requestToJSON.call(self.request)
Request = (options) ->
  
  # if tunnel property of options was not given default to false
  # if given the method property in options, set property explicitMethod to true
  
  # extend the Request instance with any non-reserved properties
  # remove any reserved functions from the options object
  # set Request instance to be readable and writable
  # call init
  self = this
  stream.Stream.call self
  reserved = Object.keys(Request::)
  nonReserved = filterForNonReserved(reserved, options)
  stream.Stream.call self
  util._extend self, nonReserved
  options = filterOutReservedFunctions(reserved, options)
  self.readable = true
  self.writable = true
  options.tunnel = false  if typeof options.tunnel is "undefined"
  self.explicitMethod = true  if options.method
  self.canTunnel = options.tunnel isnt false and tunnel
  self.init options
  return
"use strict"
http = require("http")
https = require("https")
url = require("url")
util = require("util")
stream = require("stream")
qs = require("qs")
querystring = require("querystring")
zlib = require("zlib")
helpers = require("./lib/helpers")
bl = require("bl")
oauth = require("oauth-sign")
hawk = require("hawk")
aws = require("aws-sign2")
httpSignature = require("http-signature")
uuid = require("node-uuid")
mime = require("mime-types")
tunnel = require("tunnel-agent")
stringstream = require("stringstream")
caseless = require("caseless")
ForeverAgent = require("forever-agent")
FormData = require("form-data")
cookies = require("./lib/cookies")
copy = require("./lib/copy")
debug = require("./lib/debug")
net = require("net")
safeStringify = helpers.safeStringify
md5 = helpers.md5
isReadStream = helpers.isReadStream
toBase64 = helpers.toBase64
defer = helpers.defer
globalCookieJar = cookies.jar()
globalPool = {}
isUrl = /^https?:/
defaultProxyHeaderWhiteList = [
  "accept"
  "accept-charset"
  "accept-encoding"
  "accept-language"
  "accept-ranges"
  "cache-control"
  "content-encoding"
  "content-language"
  "content-length"
  "content-location"
  "content-md5"
  "content-range"
  "content-type"
  "connection"
  "date"
  "expect"
  "max-forwards"
  "pragma"
  "proxy-authorization"
  "referer"
  "te"
  "transfer-encoding"
  "user-agent"
  "via"
]
util.inherits Request, stream.Stream
Request::setupTunnel = ->
  
  # Set up the tunneling agent if necessary
  # Only send the proxy whitelisted header names.
  # Turn on tunneling for the rest of request.
  self = this
  self.proxy = url.parse(self.proxy)  if typeof self.proxy is "string"
  return false  unless self.proxy
  return false  if not self.tunnel and self.uri.protocol isnt "https:"
  self.proxyHeaderWhiteList = defaultProxyHeaderWhiteList  unless self.proxyHeaderWhiteList
  proxyHost = constructProxyHost(self.uri)
  self.proxyHeaders = constructProxyHeaderWhiteList(self.headers, self.proxyHeaderWhiteList)
  self.proxyHeaders.host = proxyHost
  tunnelFn = getTunnelFn(self)
  tunnelOptions = construcTunnelOptions(self)
  self.agent = tunnelFn(tunnelOptions)
  self.tunnel = true
  true

Request::init = (options) ->
  
  # init() contains all the code to setup the request object.
  # the actual outgoing request is not started until start() is called
  # this function is called from both the constructor and on redirect.
  self = this
  options = {}  unless options
  self.headers = (if self.headers then copy(self.headers) else {})
  caseless.httpify self, self.headers
  
  # Never send proxy-auth to the endpoint!
  if self.hasHeader("proxy-authorization")
    self.proxyAuthorization = self.getHeader("proxy-authorization")
    self.removeHeader "proxy-authorization"
  self.method = options.method or "GET"  unless self.method
  self.localAddress = options.localAddress
  self.qsLib = ((if options.useQuerystring then querystring else qs))  unless self.qsLib
  debug options
  self.pool = globalPool  if not self.pool and self.pool isnt false
  self.dests = self.dests or []
  self.__isRequestRequest = true
  
  # Protect against double callback
  if not self._callback and self.callback
    self._callback = self.callback
    self.callback = ->
      return  if self._callbackCalled # Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply self, arguments
      return

    self.on "error", self.callback.bind()
    self.on "complete", self.callback.bind(self, null)
  
  # People use this property instead all the time, so support it
  if not self.uri and self.url
    self.uri = self.url
    delete self.url
  
  # A URI is needed by this point, throw if we haven't been able to get one
  return self.emit("error", new Error("options.uri is a required argument"))  unless self.uri
  
  # If a string URI/URL was given, parse it into a URL object
  self.uri = url.parse(self.uri)  if typeof self.uri is "string"
  
  # DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  return self.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"))  if self.uri.protocol is "unix:"
  
  # Support Unix Sockets
  if self.uri.host is "unix"
    
    # Get the socket & request paths from the URL
    unixParts = self.uri.path.split(":")
    host = unixParts[0]
    path = unixParts[1]
    
    # Apply unix properties to request
    self.socketPath = host
    self.uri.pathname = path
    self.uri.path = path
    self.uri.host = host
    self.uri.hostname = host
    self.uri.isUnix = true
  self.rejectUnauthorized = false  if self.strictSSL is false
  self.proxy = getProxyFromURI(self.uri)  unless self.hasOwnProperty("proxy")
  
  # Pass in `tunnel:true` to *always* tunnel through proxies
  self.tunnel = !!options.tunnel
  self.setupTunnel()  if self.proxy
  self.uri.pathname = "/"  unless self.uri.pathname
  if not (self.uri.host or (self.uri.hostname and self.uri.port)) and not self.uri.isUnix
    
    # Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
    # Detect and reject it as soon as possible
    faultyUri = url.format(self.uri)
    message = "Invalid URI \"" + faultyUri + "\""
    
    # No option ? This can be the sign of a redirect
    # As this is a case where the user cannot do anything (they didn't call request directly with this URL)
    # they should be warned that it can be caused by a redirection (can save some hair)
    message += ". This can be caused by a crappy redirection."  if Object.keys(options).length is 0
    
    # This error was fatal
    return self.emit("error", new Error(message))
  self._redirectsFollowed = self._redirectsFollowed or 0
  self.maxRedirects = (if (self.maxRedirects isnt `undefined`) then self.maxRedirects else 10)
  self.allowRedirect = (if (typeof self.followRedirect is "function") then self.followRedirect else (response) ->
    true
  )
  self.followRedirects = (if (self.followRedirect isnt `undefined`) then !!self.followRedirect else true)
  self.followAllRedirects = (if (self.followAllRedirects isnt `undefined`) then self.followAllRedirects else false)
  self.redirects = self.redirects or []  if self.followRedirects or self.followAllRedirects
  self.setHost = false
  unless self.hasHeader("host")
    self.setHeader "host", self.uri.hostname
    self.setHeader "host", self.getHeader("host") + (":" + self.uri.port)  if not (self.uri.port is 80 and self.uri.protocol is "http:") and not (self.uri.port is 443 and self.uri.protocol is "https:")  if self.uri.port
    self.setHost = true
  self.jar self._jar or options.jar
  unless self.uri.port
    if self.uri.protocol is "http:"
      self.uri.port = 80
    else self.uri.port = 443  if self.uri.protocol is "https:"
  if self.proxy and not self.tunnel
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  else
    self.port = self.uri.port
    self.host = self.uri.hostname
  self.form options.form  if options.form
  if options.formData
    formData = options.formData
    requestForm = self.form()
    appendFormValue = (key, value) ->
      if value.hasOwnProperty("value") and value.hasOwnProperty("options")
        requestForm.append key, value.value, value.options
      else
        requestForm.append key, value
      return

    for formKey of formData
      if formData.hasOwnProperty(formKey)
        formValue = formData[formKey]
        if formValue instanceof Array
          j = 0

          while j < formValue.length
            appendFormValue formKey, formValue[j]
            j++
        else
          appendFormValue formKey, formValue
  self.qs options.qs  if options.qs
  if self.uri.path
    self.path = self.uri.path
  else
    self.path = self.uri.pathname + (self.uri.search or "")
  self.path = "/"  if self.path.length is 0
  
  # Auth must happen last in case signing is dependent on other headers
  self.oauth options.oauth  if options.oauth
  self.aws options.aws  if options.aws
  self.hawk options.hawk  if options.hawk
  self.httpSignature options.httpSignature  if options.httpSignature
  if options.auth
    options.auth.user = options.auth.username  if Object::hasOwnProperty.call(options.auth, "username")
    options.auth.pass = options.auth.password  if Object::hasOwnProperty.call(options.auth, "password")
    self.auth options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer
  self.setHeader "accept-encoding", "gzip"  if self.gzip and not self.hasHeader("accept-encoding")
  if self.uri.auth and not self.hasHeader("authorization")
    uriAuthPieces = self.uri.auth.split(":").map((item) ->
      querystring.unescape item
    )
    self.auth uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true
  if self.proxy and not self.tunnel
    if self.proxy.auth and not self.proxyAuthorization
      proxyAuthPieces = self.proxy.auth.split(":").map((item) ->
        querystring.unescape item
      )
      authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"))
      self.proxyAuthorization = authHeader
    self.setHeader "proxy-authorization", self.proxyAuthorization  if self.proxyAuthorization
  self.path = (self.uri.protocol + "//" + self.uri.host + self.path)  if self.proxy and not self.tunnel
  if options.json
    self.json options.json
  else if options.multipart
    self.boundary = uuid()
    self.multipart options.multipart
  if self.body
    length = 0
    unless Buffer.isBuffer(self.body)
      if Array.isArray(self.body)
        i = 0

        while i < self.body.length
          length += self.body[i].length
          i++
      else
        self.body = new Buffer(self.body)
        length = self.body.length
    else
      length = self.body.length
    if length
      self.setHeader "content-length", length  unless self.hasHeader("content-length")
    else
      throw new Error("Argument error, options.body.")
  protocol = (if self.proxy and not self.tunnel then self.proxy.protocol else self.uri.protocol)
  defaultModules =
    "http:": http
    "https:": https

  httpModules = self.httpModules or {}
  self.httpModule = httpModules[protocol] or defaultModules[protocol]
  return self.emit("error", new Error("Invalid protocol: " + protocol))  unless self.httpModule
  self.ca = options.ca  if options.ca
  unless self.agent
    self.agentOptions = options.agentOptions  if options.agentOptions
    if options.agentClass
      self.agentClass = options.agentClass
    else if options.forever
      self.agentClass = (if protocol is "http:" then ForeverAgent else ForeverAgent.SSL)
    else
      self.agentClass = self.httpModule.Agent
  if self.pool is false
    self.agent = false
  else
    self.agent = self.agent or self.getAgent()
    
    # Don't use our pooling if node has the refactored client
    self.agent.maxSockets = self.maxSockets  if self.maxSockets
    
    # Don't use our pooling if node has the refactored client
    self.agent.maxSockets = self.pool.maxSockets  if self.pool.maxSockets
  self.on "pipe", (src) ->
    throw new Error("You cannot pipe to this stream after the outbound request has started.")  if self.ntick and self._started
    self.src = src
    if isReadStream(src)
      self.setHeader "content-type", mime.lookup(src.path)  unless self.hasHeader("content-type")
    else
      if src.headers
        for i of src.headers
          self.setHeader i, src.headers[i]  unless self.hasHeader(i)
      self.setHeader "content-type", "application/json"  if self._json and not self.hasHeader("content-type")
      self.method = src.method  if src.method and not self.explicitMethod
    return

  
  # self.on('pipe', function () {
  #   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
  # })
  defer ->
    return  if self._aborted
    end = ->
      self._form.pipe self  if self._form
      if self.body
        if Array.isArray(self.body)
          self.body.forEach (part) ->
            self.write part
            return

        else
          self.write self.body
        self.end()
      else if self.requestBodyStream
        console.warn "options.requestBodyStream is deprecated, please pass the request object to stream.pipe."
        self.requestBodyStream.pipe self
      else unless self.src
        self.setHeader "content-length", 0  if self.method isnt "GET" and typeof self.method isnt "undefined"
        self.end()
      return

    if self._form and not self.hasHeader("content-length")
      
      # Before ending the request, we had to compute the length of the whole form, asyncly
      self.setHeader self._form.getHeaders()
      self._form.getLength (err, length) ->
        self.setHeader "content-length", length  unless err
        end()
        return

    else
      end()
    self.ntick = true
    return

  return


# Must call this when following a redirect from https to http or vice versa
# Attempts to keep everything as identical as possible, but update the
# httpModule, Tunneling agent, and/or Forever Agent in use.
Request::_updateProtocol = ->
  self = this
  protocol = self.uri.protocol
  if protocol is "https:" or self.tunnel
    
    # previously was doing http, now doing https
    # if it's https, then we might need to tunnel now.
    return  if self.setupTunnel()  if self.proxy
    self.httpModule = https
    switch self.agentClass
      when ForeverAgent
        self.agentClass = ForeverAgent.SSL
      when http.Agent
        self.agentClass = https.Agent
      else
        
        # nothing we can do.  Just hope for the best.
        return
    
    # if there's an agent, we need to get a new one.
    self.agent = self.getAgent()  if self.agent
  else
    
    # previously was doing https, now doing http
    self.httpModule = http
    switch self.agentClass
      when ForeverAgent.SSL
        self.agentClass = ForeverAgent
      when https.Agent
        self.agentClass = http.Agent
      else
        
        # nothing we can do.  just hope for the best
        return
    
    # if there's an agent, then get a new one.
    if self.agent
      self.agent = null
      self.agent = self.getAgent()
  return

Request::getAgent = ->
  self = this
  Agent = self.agentClass
  options = {}
  if self.agentOptions
    for i of self.agentOptions
      options[i] = self.agentOptions[i]
  options.ca = self.ca  if self.ca
  options.ciphers = self.ciphers  if self.ciphers
  options.secureProtocol = self.secureProtocol  if self.secureProtocol
  options.secureOptions = self.secureOptions  if self.secureOptions
  options.rejectUnauthorized = self.rejectUnauthorized  if typeof self.rejectUnauthorized isnt "undefined"
  if self.cert and self.key
    options.key = self.key
    options.cert = self.cert
  poolKey = ""
  
  # different types of agents are in different pools
  poolKey += Agent.name  if Agent isnt self.httpModule.Agent
  unless self.httpModule.globalAgent
    
    # node 0.4.x
    options.host = self.host
    options.port = self.port
    poolKey += ":"  if poolKey
    poolKey += self.host + ":" + self.port
  
  # ca option is only relevant if proxy or destination are https
  proxy = self.proxy
  proxy = url.parse(proxy)  if typeof proxy is "string"
  isHttps = (proxy and proxy.protocol is "https:") or @uri.protocol is "https:"
  if isHttps
    if options.ca
      poolKey += ":"  if poolKey
      poolKey += options.ca
    if typeof options.rejectUnauthorized isnt "undefined"
      poolKey += ":"  if poolKey
      poolKey += options.rejectUnauthorized
    poolKey += options.cert.toString("ascii") + options.key.toString("ascii")  if options.cert
    if options.ciphers
      poolKey += ":"  if poolKey
      poolKey += options.ciphers
    if options.secureProtocol
      poolKey += ":"  if poolKey
      poolKey += options.secureProtocol
    if options.secureOptions
      poolKey += ":"  if poolKey
      poolKey += options.secureOptions
  
  # not doing anything special.  Use the globalAgent
  return self.httpModule.globalAgent  if self.pool is globalPool and not poolKey and Object.keys(options).length is 0 and self.httpModule.globalAgent
  
  # we're using a stored agent.  Make sure it's protocol-specific
  poolKey = self.uri.protocol + poolKey
  
  # generate a new agent for this setting if none yet exists
  self.pool[poolKey] = new Agent(options)  unless self.pool[poolKey]
  self.pool[poolKey]

Request::start = ->
  
  # start() is called once we are ready to send the outgoing HTTP request.
  # this is usually called on the first write(), end() or on nextTick()
  self = this
  return  if self._aborted
  self._started = true
  self.method = self.method or "GET"
  self.href = self.uri.href
  self.setHeader "content-length", self.src.stat.size  if self.src and self.src.stat and self.src.stat.size and not self.hasHeader("content-length")
  self.aws self._aws, true  if self._aws
  
  # We have a method named auth, which is completely different from the http.request
  # auth option.  If we don't remove it, we're gonna have a bad time.
  reqOptions = copy(self)
  delete reqOptions.auth

  debug "make request", self.uri.href
  self.req = self.httpModule.request(reqOptions)
  if self.timeout and not self.timeoutTimer
    self.timeoutTimer = setTimeout(->
      self.abort()
      e = new Error("ETIMEDOUT")
      e.code = "ETIMEDOUT"
      self.emit "error", e
      return
    , self.timeout)
    
    # Set additional timeout on socket - in case if remote
    # server freeze after sending headers
    if self.req.setTimeout # only works on node 0.6+
      self.req.setTimeout self.timeout, ->
        if self.req
          self.req.abort()
          e = new Error("ESOCKETTIMEDOUT")
          e.code = "ESOCKETTIMEDOUT"
          self.emit "error", e
        return

  self.req.on "response", self.onRequestResponse.bind(self)
  self.req.on "error", self.onRequestError.bind(self)
  self.req.on "drain", ->
    self.emit "drain"
    return

  self.req.on "socket", (socket) ->
    self.emit "socket", socket
    return

  self.on "end", ->
    self.req.connection.removeListener "error", connectionErrorHandler  if self.req.connection
    return

  self.emit "request", self.req
  return

Request::onRequestError = (error) ->
  self = this
  return  if self._aborted
  if self.req and self.req._reusedSocket and error.code is "ECONNRESET" and self.agent.addRequestNoreuse
    self.agent = addRequest: self.agent.addRequestNoreuse.bind(self.agent)
    self.start()
    self.req.end()
    return
  if self.timeout and self.timeoutTimer
    clearTimeout self.timeoutTimer
    self.timeoutTimer = null
  self.emit "error", error
  return

Request::onRequestResponse = (response) ->
  self = this
  debug "onRequestResponse", self.uri.href, response.statusCode, response.headers
  response.on "end", ->
    debug "response end", self.uri.href, response.statusCode, response.headers
    return

  
  # The check on response.connection is a workaround for browserify.
  if response.connection and response.connection.listeners("error").indexOf(connectionErrorHandler) is -1
    response.connection.setMaxListeners 0
    response.connection.once "error", connectionErrorHandler
  if self._aborted
    debug "aborted", self.uri.href
    response.resume()
    return
  if self._paused
    response.pause()
  
  # response.resume should be defined, but check anyway before calling. Workaround for browserify.
  else response.resume()  if response.resume
  self.response = response
  response.request = self
  response.toJSON = responseToJSON
  
  # XXX This is different on 0.10, because SSL is strict by default
  if self.httpModule is https and self.strictSSL and (not response.hasOwnProperty("client") or not response.client.authorized)
    debug "strict ssl error", self.uri.href
    sslErr = (if response.hasOwnProperty("client") then response.client.authorizationError else self.uri.href + " does not support SSL")
    self.emit "error", new Error("SSL Error: " + sslErr)
    return
  
  # Save the original host before any redirect (if it changes, we need to
  # remove any authorization headers)
  self.originalHost = self.headers.host
  self.removeHeader "host"  if self.setHost
  if self.timeout and self.timeoutTimer
    clearTimeout self.timeoutTimer
    self.timeoutTimer = null
  targetCookieJar = (if (self._jar and self._jar.setCookie) then self._jar else globalCookieJar)
  addCookie = (cookie) ->
    
    #set the cookie if it's domain in the href's domain.
    try
      targetCookieJar.setCookie cookie, self.uri.href,
        ignoreError: true

    catch e
      self.emit "error", e
    return

  response.caseless = caseless(response.headers)
  if response.caseless.has("set-cookie") and (not self._disableCookies)
    headerName = response.caseless.has("set-cookie")
    if Array.isArray(response.headers[headerName])
      response.headers[headerName].forEach addCookie
    else
      addCookie response.headers[headerName]
  redirectTo = null
  if response.statusCode >= 300 and response.statusCode < 400 and response.caseless.has("location")
    location = response.caseless.get("location")
    debug "redirect", location
    if self.followAllRedirects
      redirectTo = location
    else if self.followRedirects
      switch self.method
        when "PATCH", "PUT", "POST", "DELETE"
        
        # Do not follow redirects
        else
          redirectTo = location
  else if response.statusCode is 401 and self._hasAuth and not self._sentAuth
    authHeader = response.caseless.get("www-authenticate")
    authVerb = authHeader and authHeader.split(" ")[0].toLowerCase()
    debug "reauth", authVerb
    switch authVerb
      when "basic"
        self.auth self._user, self._pass, true
        redirectTo = self.uri
      when "bearer"
        self.auth null, null, true, self._bearer
        redirectTo = self.uri
      when "digest"
        
        # TODO: More complete implementation of RFC 2617.
        #   - check challenge.algorithm
        #   - support algorithm="MD5-sess"
        #   - handle challenge.domain
        #   - support qop="auth-int" only
        #   - handle Authentication-Info (not necessarily?)
        #   - check challenge.stale (not necessarily?)
        #   - increase nc (not necessarily?)
        # For reference:
        # http://tools.ietf.org/html/rfc2617#section-3
        # https://github.com/bagder/curl/blob/master/lib/http_digest.c
        challenge = {}
        re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/g
        loop
          match = re.exec(authHeader)
          break  unless match
          challenge[match[1]] = match[2] or match[3]
        ha1 = md5(self._user + ":" + challenge.realm + ":" + self._pass)
        ha2 = md5(self.method + ":" + self.uri.path)
        qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) and "auth"
        nc = qop and "00000001"
        cnonce = qop and uuid().replace(/-/g, "")
        digestResponse = (if qop then md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) else md5(ha1 + ":" + challenge.nonce + ":" + ha2))
        authValues =
          username: self._user
          realm: challenge.realm
          nonce: challenge.nonce
          uri: self.uri.path
          qop: qop
          response: digestResponse
          nc: nc
          cnonce: cnonce
          algorithm: challenge.algorithm
          opaque: challenge.opaque

        authHeader = []
        for k of authValues
          if authValues[k]
            if k is "qop" or k is "nc" or k is "algorithm"
              authHeader.push k + "=" + authValues[k]
            else
              authHeader.push k + "=\"" + authValues[k] + "\""
        authHeader = "Digest " + authHeader.join(", ")
        self.setHeader "authorization", authHeader
        self._sentAuth = true
        redirectTo = self.uri
  if redirectTo and self.allowRedirect.call(self, response)
    debug "redirect to", redirectTo
    
    # ignore any potential response body.  it cannot possibly be useful
    # to us at this point.
    response.resume()  if self._paused
    if self._redirectsFollowed >= self.maxRedirects
      self.emit "error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + self.uri.href)
      return
    self._redirectsFollowed += 1
    redirectTo = url.resolve(self.uri.href, redirectTo)  unless isUrl.test(redirectTo)
    uriPrev = self.uri
    self.uri = url.parse(redirectTo)
    
    # handle the case where we change protocol from https to http or vice versa
    self._updateProtocol()  if self.uri.protocol isnt uriPrev.protocol
    self.redirects.push
      statusCode: response.statusCode
      redirectUri: redirectTo

    self.method = "GET"  if self.followAllRedirects and response.statusCode isnt 401 and response.statusCode isnt 307
    
    # self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src

    delete self.req

    delete self.agent

    delete self._started

    if response.statusCode isnt 401 and response.statusCode isnt 307
      
      # Remove parameters from the previous response, unless this is the second request
      # for a server that requires digest authentication.
      delete self.body

      delete self._form

      if self.headers
        self.removeHeader "host"
        self.removeHeader "content-type"
        self.removeHeader "content-length"
        
        # Remove authorization if changing hostnames (but not if just
        # changing ports or protocols).  This matches the behavior of curl:
        # https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
        self.removeHeader "authorization"  if self.uri.hostname isnt self.originalHost.split(":")[0]
    self.emit "redirect"
    self.init()
    return # Ignore the rest of the response
  else
    self._redirectsFollowed = self._redirectsFollowed or 0
    
    # Be a good stream and emit end when the response is finished.
    # Hack to emit end on close because of a core bug that never fires end
    response.on "close", ->
      self.response.emit "end"  unless self._ended
      return

    response.on "end", ->
      self._ended = true
      return

    dataStream = undefined
    if self.gzip
      contentEncoding = response.headers["content-encoding"] or "identity"
      contentEncoding = contentEncoding.trim().toLowerCase()
      if contentEncoding is "gzip"
        dataStream = zlib.createGunzip()
        response.pipe dataStream
      else
        
        # Since previous versions didn't check for Content-Encoding header,
        # ignore any invalid values to preserve backwards-compatibility
        debug "ignoring unrecognized Content-Encoding " + contentEncoding  if contentEncoding isnt "identity"
        dataStream = response
    else
      dataStream = response
    if self.encoding
      if self.dests.length isnt 0
        console.error "Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid."
      else if dataStream.setEncoding
        dataStream.setEncoding self.encoding
      else
        
        # Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with
        # zlib streams.
        # If/When support for 0.9.4 is dropped, this should be unnecessary.
        dataStream = dataStream.pipe(stringstream(self.encoding))
    self.emit "response", response
    self.dests.forEach (dest) ->
      self.pipeDest dest
      return

    dataStream.on "data", (chunk) ->
      self._destdata = true
      self.emit "data", chunk
      return

    dataStream.on "end", (chunk) ->
      self.emit "end", chunk
      return

    dataStream.on "error", (error) ->
      self.emit "error", error
      return

    dataStream.on "close", ->
      self.emit "close"
      return

    if self.callback
      buffer = bl()
      strings = []
      self.on "data", (chunk) ->
        if Buffer.isBuffer(chunk)
          buffer.append chunk
        else
          strings.push chunk
        return

      self.on "end", ->
        debug "end event", self.uri.href
        if self._aborted
          debug "aborted", self.uri.href
          return
        if buffer.length
          debug "has body", self.uri.href, buffer.length
          if self.encoding is null
            
            # response.body = buffer
            # can't move to this until https://github.com/rvagg/bl/issues/13
            response.body = buffer.slice()
          else
            response.body = buffer.toString(self.encoding)
        else if strings.length
          
          # The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          # Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
          strings[0] = strings[0].substring(1)  if self.encoding is "utf8" and strings[0].length > 0 and strings[0][0] is "ï»¿"
          response.body = strings.join("")
        if self._json
          try
            response.body = JSON.parse(response.body)
        debug "emitting complete", self.uri.href
        response.body = ""  if typeof response.body is "undefined" and not self._json
        self.emit "complete", response, response.body
        return

    
    #if no callback
    else
      self.on "end", ->
        if self._aborted
          debug "aborted", self.uri.href
          return
        self.emit "complete", response
        return

  debug "finish init function", self.uri.href
  return

Request::abort = ->
  self = this
  self._aborted = true
  if self.req
    self.req.abort()
  else self.response.abort()  if self.response
  self.emit "abort"
  return

Request::pipeDest = (dest) ->
  self = this
  response = self.response
  
  # Called after the response is received
  if dest.headers and not dest.headersSent
    if response.caseless.has("content-type")
      ctname = response.caseless.has("content-type")
      if dest.setHeader
        dest.setHeader ctname, response.headers[ctname]
      else
        dest.headers[ctname] = response.headers[ctname]
    if response.caseless.has("content-length")
      clname = response.caseless.has("content-length")
      if dest.setHeader
        dest.setHeader clname, response.headers[clname]
      else
        dest.headers[clname] = response.headers[clname]
  if dest.setHeader and not dest.headersSent
    for i of response.headers
      
      # If the response content is being decoded, the Content-Encoding header
      # of the response doesn't represent the piped content, so don't pass it.
      dest.setHeader i, response.headers[i]  if not self.gzip or i isnt "content-encoding"
    dest.statusCode = response.statusCode
  self.pipefilter response, dest  if self.pipefilter
  return

Request::qs = (q, clobber) ->
  self = this
  base = undefined
  if not clobber and self.uri.query
    base = self.qsLib.parse(self.uri.query)
  else
    base = {}
  for i of q
    base[i] = q[i]
  return self  if self.qsLib.stringify(base) is ""
  self.uri = url.parse(self.uri.href.split("?")[0] + "?" + self.qsLib.stringify(base))
  self.url = self.uri
  self.path = self.uri.path
  self

Request::form = (form) ->
  self = this
  if form
    self.setHeader "content-type", "application/x-www-form-urlencoded"
    self.body = (if (typeof form is "string") then form.toString("utf8") else self.qsLib.stringify(form).toString("utf8"))
    return self
  
  # create form-data object
  self._form = new FormData()
  self._form

Request::multipart = (multipart) ->
  self = this
  self.body = []
  unless self.hasHeader("content-type")
    self.setHeader "content-type", "multipart/related; boundary=" + self.boundary
  else
    headerName = self.hasHeader("content-type")
    self.setHeader headerName, self.headers[headerName].split(";")[0] + "; boundary=" + self.boundary
  throw new Error("Argument error, options.multipart.")  unless multipart.forEach
  self.body.push new Buffer("\r\n")  if self.preambleCRLF
  multipart.forEach (part) ->
    body = part.body
    throw new Error("Body attribute missing in multipart.")  if typeof body is "undefined"
    delete part.body

    preamble = "--" + self.boundary + "\r\n"
    Object.keys(part).forEach (key) ->
      preamble += key + ": " + part[key] + "\r\n"
      return

    preamble += "\r\n"
    self.body.push new Buffer(preamble)
    self.body.push new Buffer(body)
    self.body.push new Buffer("\r\n")
    return

  self.body.push new Buffer("--" + self.boundary + "--")
  self.body.push new Buffer("\r\n")  if self.postambleCRLF
  self

Request::json = (val) ->
  self = this
  self.setHeader "accept", "application/json"  unless self.hasHeader("accept")
  self._json = true
  if typeof val is "boolean"
    if typeof self.body is "object"
      self.body = safeStringify(self.body)
      self.setHeader "content-type", "application/json"  unless self.hasHeader("content-type")
  else
    self.body = safeStringify(val)
    self.setHeader "content-type", "application/json"  unless self.hasHeader("content-type")
  self

Request::getHeader = (name, headers) ->
  self = this
  result = undefined
  re = undefined
  match = undefined
  headers = self.headers  unless headers
  Object.keys(headers).forEach (key) ->
    return  if key.length isnt name.length
    re = new RegExp(name, "i")
    match = key.match(re)
    result = headers[key]  if match
    return

  result

getHeader = Request::getHeader
Request::auth = (user, pass, sendImmediately, bearer) ->
  self = this
  if bearer isnt `undefined`
    self._bearer = bearer
    self._hasAuth = true
    if sendImmediately or typeof sendImmediately is "undefined"
      bearer = bearer()  if typeof bearer is "function"
      self.setHeader "authorization", "Bearer " + bearer
      self._sentAuth = true
    return self
  throw new Error("auth() received invalid user or password")  if typeof user isnt "string" or (pass isnt `undefined` and typeof pass isnt "string")
  self._user = user
  self._pass = pass
  self._hasAuth = true
  header = (if typeof pass isnt "undefined" then user + ":" + pass else user)
  if sendImmediately or typeof sendImmediately is "undefined"
    self.setHeader "authorization", "Basic " + toBase64(header)
    self._sentAuth = true
  self

Request::aws = (opts, now) ->
  self = this
  unless now
    self._aws = opts
    return self
  date = new Date()
  self.setHeader "date", date.toUTCString()
  auth =
    key: opts.key
    secret: opts.secret
    verb: self.method.toUpperCase()
    date: date
    contentType: self.getHeader("content-type") or ""
    md5: self.getHeader("content-md5") or ""
    amazonHeaders: aws.canonicalizeHeaders(self.headers)

  path = self.uri.path
  if opts.bucket and path
    auth.resource = "/" + opts.bucket + path
  else if opts.bucket and not path
    auth.resource = "/" + opts.bucket
  else if not opts.bucket and path
    auth.resource = path
  else auth.resource = "/"  if not opts.bucket and not path
  auth.resource = aws.canonicalizeResource(auth.resource)
  self.setHeader "authorization", aws.authorization(auth)
  self

Request::httpSignature = (opts) ->
  self = this
  httpSignature.signRequest
    getHeader: (header) ->
      getHeader header, self.headers

    setHeader: (header, value) ->
      self.setHeader header, value
      return

    method: self.method
    path: self.path
  , opts
  debug "httpSignature authorization", self.getHeader("authorization")
  self

Request::hawk = (opts) ->
  self = this
  self.setHeader "Authorization", hawk.client.header(self.uri, self.method, opts).field
  return

Request::oauth = (_oauth) ->
  self = this
  form = undefined
  query = undefined
  form = self.body  if self.hasHeader("content-type") and self.getHeader("content-type").slice(0, "application/x-www-form-urlencoded".length) is "application/x-www-form-urlencoded"
  query = self.uri.query  if self.uri.query
  oa = {}
  for i of _oauth
    oa["oauth_" + i] = _oauth[i]
  delete oa.oauth_realm  if "oauth_realm" of oa
  oa.oauth_version = "1.0"  unless oa.oauth_version
  oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()  unless oa.oauth_timestamp
  oa.oauth_nonce = uuid().replace(/-/g, "")  unless oa.oauth_nonce
  oa.oauth_signature_method = "HMAC-SHA1"
  consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret

  token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret

  baseurl = self.uri.protocol + "//" + self.uri.host + self.uri.pathname
  params = self.qsLib.parse([].concat(query, form, self.qsLib.stringify(oa)).join("&"))
  signature = oauth.hmacsign(self.method, baseurl, params, consumer_secret, token_secret)
  realm = (if _oauth.realm then "realm=\"" + _oauth.realm + "\"," else "")
  authHeader = "OAuth " + realm + Object.keys(oa).sort().map((i) ->
    i + "=\"" + oauth.rfc3986(oa[i]) + "\""
  ).join(",")
  authHeader += ",oauth_signature=\"" + oauth.rfc3986(signature) + "\""
  self.setHeader "Authorization", authHeader
  self

Request::jar = (jar) ->
  self = this
  cookies = undefined
  self.originalCookieHeader = self.getHeader("cookie")  if self._redirectsFollowed is 0
  unless jar
    
    # disable cookies
    cookies = false
    self._disableCookies = true
  else
    targetCookieJar = (if (jar and jar.getCookieString) then jar else globalCookieJar)
    urihref = self.uri.href
    
    #fetch cookie in the Specified host
    cookies = targetCookieJar.getCookieString(urihref)  if targetCookieJar
  
  #if need cookie and cookie is not empty
  if cookies and cookies.length
    if self.originalCookieHeader
      
      # Don't overwrite existing Cookie header
      self.setHeader "cookie", self.originalCookieHeader + "; " + cookies
    else
      self.setHeader "cookie", cookies
  self._jar = jar
  self


# Stream API
Request::pipe = (dest, opts) ->
  self = this
  if self.response
    if self._destdata
      throw new Error("You cannot pipe after data has been emitted from the response.")
    else if self._ended
      throw new Error("You cannot pipe after the response has been ended.")
    else
      stream.Stream::pipe.call self, dest, opts
      self.pipeDest dest
      dest
  else
    self.dests.push dest
    stream.Stream::pipe.call self, dest, opts
    dest
  return

Request::write = ->
  self = this
  self.start()  unless self._started
  self.req.write.apply self.req, arguments

Request::end = (chunk) ->
  self = this
  self.write chunk  if chunk
  self.start()  unless self._started
  self.req.end()
  return

Request::pause = ->
  self = this
  unless self.response
    self._paused = true
  else
    self.response.pause.apply self.response, arguments
  return

Request::resume = ->
  self = this
  unless self.response
    self._paused = false
  else
    self.response.resume.apply self.response, arguments
  return

Request::destroy = ->
  self = this
  unless self._ended
    self.end()
  else self.response.destroy()  if self.response
  return

Request.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList.slice()

# Exports
Request::toJSON = requestToJSON
module.exports = Request
