# This file is automatically generated by scheme2js, except for the
# benchmark harness code at the beginning and end of the file.

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

###*
GENERATED FILE - DO NOT EDIT ************
###

#
# * To use write/prints/... the default-output port has to be set first.
# * Simply setting SC_DEFAULT_OUT and SC_ERROR_OUT to the desired values
# * should do the trick.
# * In the following example the std-out and error-port are redirected to
# * a DIV.
#function initRuntime() {
#    function escapeHTML(s) {
#	var tmp = s;
#	tmp = tmp.replace(/&/g, "&amp;");
#	tmp = tmp.replace(/</g, "&lt;");
#	tmp = tmp.replace(/>/g, "&gt;");
#	tmp = tmp.replace(/ /g, "&nbsp;");
#	tmp = tmp.replace(/\n/g, "<br />");
#	tmp = tmp.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp");
#	return tmp;
#	
#    }
#
#    document.write("<div id='stdout'></div>");
#    SC_DEFAULT_OUT = new sc_GenericOutputPort(
#	function(s) {
#	    var stdout = document.getElementById('stdout');
#	    stdout.innerHTML = stdout.innerHTML + escapeHTML(s);
#	});
#    SC_ERROR_OUT = SC_DEFAULT_OUT;
#}
#
sc_print_debug = ->
  sc_print.apply null, arguments
  return

###*
META ((export *js*))
###

###*
META ((export #t))
###
sc_alert = ->
  len = arguments.length
  s = ""
  i = undefined
  i = 0
  while i < len
    s += sc_toDisplayString(arguments[i])
    i++
  alert s

###*
META ((export #t))
###
sc_typeof = (x) ->
  typeof x

###*
META ((export #t))
###
sc_error = ->
  a = [sc_jsstring2symbol("*error*")]
  i = 0

  while i < arguments.length
    a[i + 1] = arguments[i]
    i++
  throw areturn

###*
META ((export #t)
(peephole (prefix "throw ")))
###
sc_raise = (obj) ->
  throw objreturn

###*
META ((export with-handler-lambda))
###
sc_withHandlerLambda = (handler, body) ->
  try
    return body()
  catch e
    unless e._internalException
      return handler(e)
    else
      throw e
  return

###*
META ((export #t))
###
sc_putpropBang = (sym, key, val) ->
  ht = sc_properties[sym]
  unless ht
    ht = new Object()
    sc_properties[sym] = ht
  ht[key] = val
  return

###*
META ((export #t))
###
sc_getprop = (sym, key) ->
  ht = sc_properties[sym]
  if ht
    if key of ht
      ht[key]
    else
      false
  else
    false

###*
META ((export #t))
###
sc_rempropBang = (sym, key) ->
  ht = sc_properties[sym]
  delete ht[key]  if ht
  return

###*
META ((export #t))
###
sc_any2String = (o) ->
  jsstring2string sc_toDisplayString(o)

###*
META ((export #t)
(peephole (infix 2 2 "==="))
(type bool))
###
sc_isEqv = (o1, o2) ->
  o1 is o2

###*
META ((export #t)
(peephole (infix 2 2 "==="))
(type bool))
###
sc_isEq = (o1, o2) ->
  o1 is o2

###*
META ((export #t)
(type bool))
###
sc_isNumber = (n) ->
  typeof n is "number"

###*
META ((export #t)
(type bool))
###
sc_isComplex = (n) ->
  sc_isNumber n

###*
META ((export #t)
(type bool))
###
sc_isReal = (n) ->
  sc_isNumber n

###*
META ((export #t)
(type bool))
###
sc_isRational = (n) ->
  sc_isReal n

###*
META ((export #t)
(type bool))
###
sc_isInteger = (n) ->
  parseInt(n) is n

###*
META ((export #t)
(type bool)
(peephole (postfix ", false")))
###

# we don't have exact numbers...
sc_isExact = (n) ->
  false

###*
META ((export #t)
(peephole (postfix ", true"))
(type bool))
###
sc_isInexact = (n) ->
  true

###*
META ((export = =fx =fl)
(type bool)
(peephole (infix 2 2 "===")))
###
sc_equal = (x) ->
  i = 1

  while i < arguments.length
    return false  if x isnt arguments[i]
    i++
  true

###*
META ((export < <fx <fl)
(type bool)
(peephole (infix 2 2 "<")))
###
sc_less = (x) ->
  i = 1

  while i < arguments.length
    return false  if x >= arguments[i]
    x = arguments[i]
    i++
  true

###*
META ((export > >fx >fl)
(type bool)
(peephole (infix 2 2 ">")))
###
sc_greater = (x, y) ->
  i = 1

  while i < arguments.length
    return false  if x <= arguments[i]
    x = arguments[i]
    i++
  true

###*
META ((export <= <=fx <=fl)
(type bool)
(peephole (infix 2 2 "<=")))
###
sc_lessEqual = (x, y) ->
  i = 1

  while i < arguments.length
    return false  if x > arguments[i]
    x = arguments[i]
    i++
  true

###*
META ((export >= >=fl >=fx)
(type bool)
(peephole (infix 2 2 ">=")))
###
sc_greaterEqual = (x, y) ->
  i = 1

  while i < arguments.length
    return false  if x < arguments[i]
    x = arguments[i]
    i++
  true

###*
META ((export #t)
(type bool)
(peephole (postfix "=== 0")))
###
sc_isZero = (x) ->
  x is 0

###*
META ((export #t)
(type bool)
(peephole (postfix "> 0")))
###
sc_isPositive = (x) ->
  x > 0

###*
META ((export #t)
(type bool)
(peephole (postfix "< 0")))
###
sc_isNegative = (x) ->
  x < 0

###*
META ((export #t)
(type bool)
(peephole (postfix "%2===1")))
###
sc_isOdd = (x) ->
  x % 2 is 1

###*
META ((export #t)
(type bool)
(peephole (postfix "%2===0")))
###
sc_isEven = (x) ->
  x % 2 is 0

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export + +fx +fl)
(peephole (infix 0 #f "+" "0")))
###
sc_plus = ->
  sum = 0
  i = 0

  while i < arguments.length
    sum += arguments[i]
    i++
  sum

###*
META ((export * *fx *fl)
(peephole (infix 0 #f "*" "1")))
###
sc_multi = ->
  product = 1
  i = 0

  while i < arguments.length
    product *= arguments[i]
    i++
  product

###*
META ((export - -fx -fl)
(peephole (minus)))
###
sc_minus = (x) ->
  if arguments.length is 1
    -x
  else
    res = x
    i = 1

    while i < arguments.length
      res -= arguments[i]
      i++
    res

###*
META ((export / /fl)
(peephole (div)))
###
sc_div = (x) ->
  if arguments.length is 1
    1 / x
  else
    res = x
    i = 1

    while i < arguments.length
      res /= arguments[i]
      i++
    res

###*
META ((export #t))
###

###*
META ((export quotient /fx)
(peephole (hole 2 "parseInt(" x "/" y ")")))
###
sc_quotient = (x, y) ->
  parseInt x / y

###*
META ((export #t)
(peephole (infix 2 2 "%")))
###
sc_remainder = (x, y) ->
  x % y

###*
META ((export #t)
(peephole (modulo)))
###
sc_modulo = (x, y) ->
  remainder = x % y
  
  # if they don't have the same sign
  if (remainder * y) < 0
    remainder + y
  else
    remainder
sc_euclid_gcd = (a, b) ->
  temp = undefined
  return b  if a is 0
  return a  if b is 0
  a = -a  if a < 0
  b = -b  if b < 0
  if b > a
    temp = a
    a = b
    b = temp
  loop
    a %= b
    return b  if a is 0
    b %= a
    return a  if b is 0
  b

###*
META ((export #t))
###
sc_gcd = ->
  gcd = 0
  i = 0

  while i < arguments.length
    gcd = sc_euclid_gcd(gcd, arguments[i])
    i++
  gcd

###*
META ((export #t))
###
sc_lcm = ->
  lcm = 1
  i = 0

  while i < arguments.length
    f = Math.round(arguments[i] / sc_euclid_gcd(arguments[i], lcm))
    lcm *= Math.abs(f)
    i++
  lcm

# LIMITATION: numerator and denominator don't make sense in floating point world.
#var SC_MAX_DECIMALS = 1000000
#
# function sc_numerator(x) {
#     var rounded = Math.round(x * SC_MAX_DECIMALS);
#     return Math.round(rounded / sc_euclid_gcd(rounded, SC_MAX_DECIMALS));
# }

# function sc_denominator(x) {
#     var rounded = Math.round(x * SC_MAX_DECIMALS);
#     return Math.round(SC_MAX_DECIMALS / sc_euclid_gcd(rounded, SC_MAX_DECIMALS));
# }

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

# LIMITATION: sc_rationalize doesn't make sense in a floating point world.

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t))
###

# LIMITATION: we don't have complex numbers.
# LIMITATION: the following functions are hence not implemented.
# LIMITATION: make-rectangular, make-polar, real-part, imag-part, magnitude, angle
# LIMITATION: 2 argument atan

###*
META ((export #t)
(peephole (id)))
###
sc_exact2inexact = (x) ->
  x

###*
META ((export #t)
(peephole (id)))
###
sc_inexact2exact = (x) ->
  x
sc_number2jsstring = (x, radix) ->
  if radix
    x.toString radix
  else
    x.toString()
sc_jsstring2number = (s, radix) ->
  return false  if s is ""
  if radix
    t = parseInt(s, radix)
    return false  if not t and t isnt 0
    
    # verify that each char is in range. (parseInt ignores leading
    # white and trailing chars)
    allowedChars = "01234567890abcdefghijklmnopqrstuvwxyz".substring(0, radix + 1)
    if (new RegExp("^[" + allowedChars + "]*$", "i")).test(s)
      t
    else
      false
  else
    t = +s # does not ignore trailing chars.
    return false  if not t and t isnt 0
    
    # simply verify that first char is not whitespace.
    c = s.charAt(0)
    
    # if +c is 0, but the char is not "0", then we have a whitespace.
    return false  if +c is 0 and c isnt "0"
    t

###*
META ((export #t)
(type bool)
(peephole (not)))
###
sc_not = (b) ->
  b is false

###*
META ((export #t)
(type bool))
###
sc_isBoolean = (b) ->
  (b is true) or (b is false)
sc_Pair = (car, cdr) ->
  @car = car
  @cdr = cdr
  return
# current.cdr == null

# sc_Pair.prototype.sc_toWriteCircleString in IO.js

###*
META ((export #t)
(type bool)
(peephole (postfix " instanceof sc_Pair")))
###
sc_isPair = (p) ->
  p instanceof sc_Pair
sc_isPairEqual = (p1, p2, comp) ->
  comp(p1.car, p2.car) and comp(p1.cdr, p2.cdr)

###*
META ((export #t)
(peephole (hole 2 "new sc_Pair(" car ", " cdr ")")))
###
sc_cons = (car, cdr) ->
  new sc_Pair(car, cdr)

###*
META ((export cons*))
###
sc_consStar = ->
  res = arguments[arguments.length - 1]
  i = arguments.length - 2

  while i >= 0
    res = new sc_Pair(arguments[i], res)
    i--
  res

###*
META ((export #t)
(peephole (postfix ".car")))
###
sc_car = (p) ->
  p.car

###*
META ((export #t)
(peephole (postfix ".cdr")))
###
sc_cdr = (p) ->
  p.cdr

###*
META ((export #t)
(peephole (hole 2 p ".car = " val)))
###
sc_setCarBang = (p, val) ->
  p.car = val
  return

###*
META ((export #t)
(peephole (hole 2 p ".cdr = " val)))
###
sc_setCdrBang = (p, val) ->
  p.cdr = val
  return

###*
META ((export #t)
(peephole (postfix ".car.car")))
###
sc_caar = (p) ->
  p.car.car

###*
META ((export #t)
(peephole (postfix ".cdr.car")))
###
sc_cadr = (p) ->
  p.cdr.car

###*
META ((export #t)
(peephole (postfix ".car.cdr")))
###
sc_cdar = (p) ->
  p.car.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.cdr")))
###
sc_cddr = (p) ->
  p.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".car.car.car")))
###
sc_caaar = (p) ->
  p.car.car.car

###*
META ((export #t)
(peephole (postfix ".car.cdr.car")))
###
sc_cadar = (p) ->
  p.car.cdr.car

###*
META ((export #t)
(peephole (postfix ".cdr.car.car")))
###
sc_caadr = (p) ->
  p.cdr.car.car

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.car")))
###
sc_caddr = (p) ->
  p.cdr.cdr.car

###*
META ((export #t)
(peephole (postfix ".car.car.cdr")))
###
sc_cdaar = (p) ->
  p.car.car.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.car.cdr")))
###
sc_cdadr = (p) ->
  p.cdr.car.cdr

###*
META ((export #t)
(peephole (postfix ".car.cdr.cdr")))
###
sc_cddar = (p) ->
  p.car.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.cdr")))
###
sc_cdddr = (p) ->
  p.cdr.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".car.car.car.car")))
###
sc_caaaar = (p) ->
  p.car.car.car.car

###*
META ((export #t)
(peephole (postfix ".car.cdr.car.car")))
###
sc_caadar = (p) ->
  p.car.cdr.car.car

###*
META ((export #t)
(peephole (postfix ".cdr.car.car.car")))
###
sc_caaadr = (p) ->
  p.cdr.car.car.car

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.car.car")))
###
sc_caaddr = (p) ->
  p.cdr.cdr.car.car

###*
META ((export #t)
(peephole (postfix ".car.car.car.cdr")))
###
sc_cdaaar = (p) ->
  p.car.car.car.cdr

###*
META ((export #t)
(peephole (postfix ".car.cdr.car.cdr")))
###
sc_cdadar = (p) ->
  p.car.cdr.car.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.car.car.cdr")))
###
sc_cdaadr = (p) ->
  p.cdr.car.car.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.car.cdr")))
###
sc_cdaddr = (p) ->
  p.cdr.cdr.car.cdr

###*
META ((export #t)
(peephole (postfix ".car.car.cdr.car")))
###
sc_cadaar = (p) ->
  p.car.car.cdr.car

###*
META ((export #t)
(peephole (postfix ".car.cdr.cdr.car")))
###
sc_caddar = (p) ->
  p.car.cdr.cdr.car

###*
META ((export #t)
(peephole (postfix ".cdr.car.cdr.car")))
###
sc_cadadr = (p) ->
  p.cdr.car.cdr.car

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.cdr.car")))
###
sc_cadddr = (p) ->
  p.cdr.cdr.cdr.car

###*
META ((export #t)
(peephole (postfix ".car.car.cdr.cdr")))
###
sc_cddaar = (p) ->
  p.car.car.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".car.cdr.cdr.cdr")))
###
sc_cdddar = (p) ->
  p.car.cdr.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.car.cdr.cdr")))
###
sc_cddadr = (p) ->
  p.cdr.car.cdr.cdr

###*
META ((export #t)
(peephole (postfix ".cdr.cdr.cdr.cdr")))
###
sc_cddddr = (p) ->
  p.cdr.cdr.cdr.cdr

###*
META ((export #t))
###
sc_lastPair = (l) ->
  sc_error "sc_lastPair: pair expected"  unless sc_isPair(l)
  res = l
  cdr = l.cdr
  while sc_isPair(cdr)
    res = cdr
    cdr = res.cdr
  res

###*
META ((export #t)
(type bool)
(peephole (postfix " === null")))
###
sc_isNull = (o) ->
  o is null

###*
META ((export #t)
(type bool))
###
sc_isList = (o) ->
  rabbit = undefined
  turtle = undefined
  rabbit = o
  turtle = o
  loop
    if rabbit is null or (rabbit instanceof sc_Pair and rabbit.cdr is null)
      return true # end of list
    else if (rabbit instanceof sc_Pair) and (rabbit.cdr instanceof sc_Pair)
      rabbit = rabbit.cdr.cdr
      turtle = turtle.cdr
      return false  if rabbit is turtle # cycle
    else # not pair
      return false
  return

###*
META ((export #t))
###
sc_list = ->
  res = null
  a = arguments
  i = a.length - 1

  while i >= 0
    res = new sc_Pair(a[i], res)
    i--
  res

###*
META ((export #t))
###
sc_iota = (num, init) ->
  res = null
  init = 0  unless init
  i = num - 1

  while i >= 0
    res = new sc_Pair(i + init, res)
    i--
  res

###*
META ((export #t))
###
sc_makeList = (nbEls, fill) ->
  res = null
  i = 0

  while i < nbEls
    res = new sc_Pair(fill, res)
    i++
  res

###*
META ((export #t))
###
sc_length = (l) ->
  res = 0
  while l isnt null
    res++
    l = l.cdr
  res

###*
META ((export #t))
###
sc_remq = (o, l) ->
  dummy = cdr: null
  tail = dummy
  while l isnt null
    if l.car isnt o
      tail.cdr = sc_cons(l.car, null)
      tail = tail.cdr
    l = l.cdr
  dummy.cdr

###*
META ((export #t))
###
sc_remqBang = (o, l) ->
  dummy = cdr: null
  tail = dummy
  needsAssig = true
  while l isnt null
    if l.car is o
      needsAssig = true
    else
      if needsAssig
        tail.cdr = l
        needsAssig = false
      tail = l
    l = l.cdr
  tail.cdr = null
  dummy.cdr

###*
META ((export #t))
###
sc_delete = (o, l) ->
  dummy = cdr: null
  tail = dummy
  while l isnt null
    unless sc_isEqual(l.car, o)
      tail.cdr = sc_cons(l.car, null)
      tail = tail.cdr
    l = l.cdr
  dummy.cdr

###*
META ((export #t))
###
sc_deleteBang = (o, l) ->
  dummy = cdr: null
  tail = dummy
  needsAssig = true
  while l isnt null
    if sc_isEqual(l.car, o)
      needsAssig = true
    else
      if needsAssig
        tail.cdr = l
        needsAssig = false
      tail = l
    l = l.cdr
  tail.cdr = null
  dummy.cdr
sc_reverseAppendBang = (l1, l2) ->
  res = l2
  while l1 isnt null
    tmp = res
    res = l1
    l1 = l1.cdr
    res.cdr = tmp
  res
sc_dualAppend = (l1, l2) ->
  return l2  if l1 is null
  return l1  if l2 is null
  rev = sc_reverse(l1)
  sc_reverseAppendBang rev, l2

###*
META ((export #t))
###
sc_append = ->
  return null  if arguments.length is 0
  res = arguments[arguments.length - 1]
  i = arguments.length - 2

  while i >= 0
    res = sc_dualAppend(arguments[i], res)
    i--
  res
sc_dualAppendBang = (l1, l2) ->
  return l2  if l1 is null
  return l1  if l2 is null
  tmp = l1
  tmp = tmp.cdr  while tmp.cdr isnt null
  tmp.cdr = l2
  l1

###*
META ((export #t))
###
sc_appendBang = ->
  res = null
  i = 0

  while i < arguments.length
    res = sc_dualAppendBang(res, arguments[i])
    i++
  res

###*
META ((export #t))
###
sc_reverse = (l1) ->
  res = null
  while l1 isnt null
    res = sc_cons(l1.car, res)
    l1 = l1.cdr
  res

###*
META ((export #t))
###
sc_reverseBang = (l) ->
  sc_reverseAppendBang l, null

###*
META ((export #t))
###
sc_listTail = (l, k) ->
  res = l
  i = 0

  while i < k
    res = res.cdr
    i++
  res

###*
META ((export #t))
###
sc_listRef = (l, k) ->
  sc_listTail(l, k).car

# // unoptimized generic versions
#function sc_memX(o, l, comp) {
#    while (l != null) {
#	if (comp(l.car, o))
#	    return l;
#	l = l.cdr;
#    }
#    return false;
#}
#function sc_memq(o, l) { return sc_memX(o, l, sc_isEq); }
#function sc_memv(o, l) { return sc_memX(o, l, sc_isEqv); }
#function sc_member(o, l) { return sc_memX(o, l, sc_isEqual); }
#

# optimized versions 

###*
META ((export #t))
###
sc_memq = (o, l) ->
  while l isnt null
    return l  if l.car is o
    l = l.cdr
  false

###*
META ((export #t))
###
sc_memv = (o, l) ->
  while l isnt null
    return l  if l.car is o
    l = l.cdr
  false

###*
META ((export #t))
###
sc_member = (o, l) ->
  while l isnt null
    return l  if sc_isEqual(l.car, o)
    l = l.cdr
  false

# // generic unoptimized versions
#function sc_assX(o, al, comp) {
#    while (al != null) {
#	if (comp(al.car.car, o))
#	    return al.car;
#	al = al.cdr;
#    }
#    return false;
#}
#function sc_assq(o, al) { return sc_assX(o, al, sc_isEq); }
#function sc_assv(o, al) { return sc_assX(o, al, sc_isEqv); }
#function sc_assoc(o, al) { return sc_assX(o, al, sc_isEqual); }
#

# optimized versions
###*
META ((export #t))
###
sc_assq = (o, al) ->
  while al isnt null
    return al.car  if al.car.car is o
    al = al.cdr
  false

###*
META ((export #t))
###
sc_assv = (o, al) ->
  while al isnt null
    return al.car  if al.car.car is o
    al = al.cdr
  false

###*
META ((export #t))
###
sc_assoc = (o, al) ->
  while al isnt null
    return al.car  if sc_isEqual(al.car.car, o)
    al = al.cdr
  false

# can be used for mutable strings and characters 
sc_isCharStringEqual = (cs1, cs2) ->
  cs1.val is cs2.val
sc_isCharStringLess = (cs1, cs2) ->
  cs1.val < cs2.val
sc_isCharStringGreater = (cs1, cs2) ->
  cs1.val > cs2.val
sc_isCharStringLessEqual = (cs1, cs2) ->
  cs1.val <= cs2.val
sc_isCharStringGreaterEqual = (cs1, cs2) ->
  cs1.val >= cs2.val
sc_isCharStringCIEqual = (cs1, cs2) ->
  cs1.val.toLowerCase() is cs2.val.toLowerCase()
sc_isCharStringCILess = (cs1, cs2) ->
  cs1.val.toLowerCase() < cs2.val.toLowerCase()
sc_isCharStringCIGreater = (cs1, cs2) ->
  cs1.val.toLowerCase() > cs2.val.toLowerCase()
sc_isCharStringCILessEqual = (cs1, cs2) ->
  cs1.val.toLowerCase() <= cs2.val.toLowerCase()
sc_isCharStringCIGreaterEqual = (cs1, cs2) ->
  cs1.val.toLowerCase() >= cs2.val.toLowerCase()
sc_Char = (c) ->
  cached = sc_Char.lazy[c]
  return cached  if cached
  @val = c
  sc_Char.lazy[c] = this
  
  # add return, so FF does not complain.
  `undefined`

# thanks to Eric

# poeticless names 

# sc_toDisplayString == toString

###*
META ((export #t)
(type bool)
(peephole (postfix "instanceof sc_Char")))
###
sc_isChar = (c) ->
  c instanceof sc_Char

###*
META ((export char=?)
(type bool)
(peephole (hole 2 c1 ".val === " c2 ".val")))
###

###*
META ((export char<?)
(type bool)
(peephole (hole 2 c1 ".val < " c2 ".val")))
###

###*
META ((export char>?)
(type bool)
(peephole (hole 2 c1 ".val > " c2 ".val")))
###

###*
META ((export char<=?)
(type bool)
(peephole (hole 2 c1 ".val <= " c2 ".val")))
###

###*
META ((export char>=?)
(type bool)
(peephole (hole 2 c1 ".val >= " c2 ".val")))
###

###*
META ((export char-ci=?)
(type bool)
(peephole (hole 2 c1 ".val.toLowerCase() === " c2 ".val.toLowerCase()")))
###

###*
META ((export char-ci<?)
(type bool)
(peephole (hole 2 c1 ".val.toLowerCase() < " c2 ".val.toLowerCase()")))
###

###*
META ((export char-ci>?)
(type bool)
(peephole (hole 2 c1 ".val.toLowerCase() > " c2 ".val.toLowerCase()")))
###

###*
META ((export char-ci<=?)
(type bool)
(peephole (hole 2 c1 ".val.toLowerCase() <= " c2 ".val.toLowerCase()")))
###

###*
META ((export char-ci>=?)
(type bool)
(peephole (hole 2 c1 ".val.toLowerCase() >= " c2 ".val.toLowerCase()")))
###
sc_isCharOfClass = (c, cl) ->
  cl.indexOf(c) isnt -1

###*
META ((export #t)
(type bool))
###
sc_isCharAlphabetic = (c) ->
  sc_isCharOfClass(c.val, SC_LOWER_CLASS) or sc_isCharOfClass(c.val, SC_UPPER_CLASS)

###*
META ((export #t)
(type bool)
(peephole (hole 1 "SC_NUMBER_CLASS.indexOf(" c ".val) != -1")))
###
sc_isCharNumeric = (c) ->
  sc_isCharOfClass c.val, SC_NUMBER_CLASS

###*
META ((export #t)
(type bool))
###
sc_isCharWhitespace = (c) ->
  tmp = c.val
  tmp is " " or tmp is "\r" or tmp is "\n" or tmp is "\t" or tmp is "\f"

###*
META ((export #t)
(type bool)
(peephole (hole 1 "SC_UPPER_CLASS.indexOf(" c ".val) != -1")))
###
sc_isCharUpperCase = (c) ->
  sc_isCharOfClass c.val, SC_UPPER_CLASS

###*
META ((export #t)
(type bool)
(peephole (hole 1 "SC_LOWER_CLASS.indexOf(" c ".val) != -1")))
###
sc_isCharLowerCase = (c) ->
  sc_isCharOfClass c.val, SC_LOWER_CLASS

###*
META ((export #t)
(peephole (postfix ".val.charCodeAt(0)")))
###
sc_char2integer = (c) ->
  c.val.charCodeAt 0

###*
META ((export #t)
(peephole (hole 1 "new sc_Char(String.fromCharCode(" n "))")))
###
sc_integer2char = (n) ->
  new sc_Char(String.fromCharCode(n))

###*
META ((export #t)
(peephole (hole 1 "new sc_Char(" c ".val.toUpperCase())")))
###
sc_charUpcase = (c) ->
  new sc_Char(c.val.toUpperCase())

###*
META ((export #t)
(peephole (hole 1 "new sc_Char(" c ".val.toLowerCase())")))
###
sc_charDowncase = (c) ->
  new sc_Char(c.val.toLowerCase())
sc_makeJSStringOfLength = (k, c) ->
  fill = undefined
  if c is `undefined`
    fill = " "
  else
    fill = c
  res = ""
  len = 1
  
  # every round doubles the size of fill.
  while k >= len
    res = res.concat(fill)  if k & len
    fill = fill.concat(fill)
    len *= 2
  res
sc_makejsString = (k, c) ->
  fill = undefined
  if c
    fill = c.val
  else
    fill = " "
  sc_makeJSStringOfLength k, fill
sc_jsstring2list = (s) ->
  res = null
  i = s.length - 1

  while i >= 0
    res = sc_cons(new sc_Char(s.charAt(i)), res)
    i--
  res
sc_list2jsstring = (l) ->
  a = new Array()
  while l isnt null
    a.push l.car.val
    l = l.cdr
  "".concat.apply "", a

###*
META ((export vector? array?)
(type bool)
(peephole (postfix " instanceof sc_Vector")))
###
sc_isVector = (v) ->
  v instanceof sc_Vector

# only applies to vectors
sc_isVectorEqual = (v1, v2, comp) ->
  return false  if v1.length isnt v2.length
  i = 0

  while i < v1.length
    return false  unless comp(v1[i], v2[i])
    i++
  true

###*
META ((export make-vector make-array))
###
sc_makeVector = (size, fill) ->
  a = new sc_Vector(size)
  sc_vectorFillBang a, fill  if fill isnt `undefined`
  a

###*
META ((export vector array)
(peephole (vector)))
###
sc_vector = ->
  a = new sc_Vector()
  i = 0

  while i < arguments.length
    a.push arguments[i]
    i++
  a

###*
META ((export vector-length array-length)
(peephole (postfix ".length")))
###
sc_vectorLength = (v) ->
  v.length

###*
META ((export vector-ref array-ref)
(peephole (hole 2 v "[" pos "]")))
###
sc_vectorRef = (v, pos) ->
  v[pos]

###*
META ((export vector-set! array-set!)
(peephole (hole 3 v "[" pos "] = " val)))
###
sc_vectorSetBang = (v, pos, val) ->
  v[pos] = val
  return

###*
META ((export vector->list array->list))
###
sc_vector2list = (a) ->
  res = null
  i = a.length - 1

  while i >= 0
    res = sc_cons(a[i], res)
    i--
  res

###*
META ((export list->vector list->array))
###
sc_list2vector = (l) ->
  a = new sc_Vector()
  while l isnt null
    a.push l.car
    l = l.cdr
  a

###*
META ((export vector-fill! array-fill!))
###
sc_vectorFillBang = (a, fill) ->
  i = 0

  while i < a.length
    a[i] = fill
    i++
  return

###*
META ((export #t))
###
sc_copyVector = (a, len) ->
  if len <= a.length
    a.slice 0, len
  else
    tmp = a.concat()
    tmp.length = len
    tmp

###*
META ((export #t)
(peephole (hole 3 a ".slice(" start "," end ")")))
###
sc_vectorCopy = (a, start, end) ->
  a.slice start, end

###*
META ((export #t))
###
sc_vectorCopyBang = (target, tstart, source, sstart, send) ->
  sstart = 0  unless sstart
  send = source.length  unless send
  
  # if target == source we don't want to overwrite not yet copied elements.
  if tstart <= sstart
    i = tstart
    j = sstart

    while j < send
      target[i] = source[j]
      i++
      j++
  else
    diff = send - sstart
    i = tstart + diff - 1
    j = send - 1

    while j >= sstart
      target[i] = source[j]
      i--
      j--
  target

###*
META ((export #t)
(type bool)
(peephole (hole 1 "typeof " o " === 'function'")))
###
sc_isProcedure = (o) ->
  typeof o is "function"

###*
META ((export #t))
###
sc_apply = (proc) ->
  args = new Array()
  
  # first part of arguments are not in list-form.
  i = 1

  while i < arguments.length - 1
    args.push arguments[i]
    i++
  l = arguments[arguments.length - 1]
  while l isnt null
    args.push l.car
    l = l.cdr
  proc.apply null, args

###*
META ((export #t))
###
sc_map = (proc, l1) ->
  return null  if l1 is `undefined`
  
  # else
  nbApplyArgs = arguments.length - 1
  applyArgs = new Array(nbApplyArgs)
  revres = null
  while l1 isnt null
    i = 0

    while i < nbApplyArgs
      applyArgs[i] = arguments[i + 1].car
      arguments[i + 1] = arguments[i + 1].cdr
      i++
    revres = sc_cons(proc.apply(null, applyArgs), revres)
  sc_reverseAppendBang revres, null

###*
META ((export #t))
###
sc_mapBang = (proc, l1) ->
  return null  if l1 is `undefined`
  
  # else
  l1_orig = l1
  nbApplyArgs = arguments.length - 1
  applyArgs = new Array(nbApplyArgs)
  while l1 isnt null
    tmp = l1
    i = 0

    while i < nbApplyArgs
      applyArgs[i] = arguments[i + 1].car
      arguments[i + 1] = arguments[i + 1].cdr
      i++
    tmp.car = proc.apply(null, applyArgs)
  l1_orig

###*
META ((export #t))
###
sc_forEach = (proc, l1) ->
  return `undefined`  if l1 is `undefined`
  
  # else
  nbApplyArgs = arguments.length - 1
  applyArgs = new Array(nbApplyArgs)
  while l1 isnt null
    i = 0

    while i < nbApplyArgs
      applyArgs[i] = arguments[i + 1].car
      arguments[i + 1] = arguments[i + 1].cdr
      i++
    proc.apply null, applyArgs
  
  # add return so FF does not complain.
  `undefined`

###*
META ((export #t))
###
sc_filter = (proc, l1) ->
  dummy = cdr: null
  tail = dummy
  while l1 isnt null
    if proc(l1.car) isnt false
      tail.cdr = sc_cons(l1.car, null)
      tail = tail.cdr
    l1 = l1.cdr
  dummy.cdr

###*
META ((export #t))
###
sc_filterBang = (proc, l1) ->
  head = sc_cons("dummy", l1)
  it = head
  next = l1
  while next isnt null
    if proc(next.car) isnt false
      it.cdr = next
      it = next
    next = next.cdr
  it.cdr = null
  head.cdr
sc_filterMap1 = (proc, l1) ->
  revres = null
  while l1 isnt null
    tmp = proc(l1.car)
    revres = sc_cons(tmp, revres)  if tmp isnt false
    l1 = l1.cdr
  sc_reverseAppendBang revres, null
sc_filterMap2 = (proc, l1, l2) ->
  revres = null
  while l1 isnt null
    tmp = proc(l1.car, l2.car)
    revres = sc_cons(tmp, revres)  if tmp isnt false
    l1 = l1.cdr
    l2 = l2.cdr
  sc_reverseAppendBang revres, null

###*
META ((export #t))
###
sc_filterMap = (proc, l1, l2, l3) ->
  if l2 is `undefined`
    return sc_filterMap1(proc, l1)
  else return sc_filterMap2(proc, l1, l2)  if l3 is `undefined`
  
  # else
  nbApplyArgs = arguments.length - 1
  applyArgs = new Array(nbApplyArgs)
  revres = null
  while l1 isnt null
    i = 0

    while i < nbApplyArgs
      applyArgs[i] = arguments[i + 1].car
      arguments[i + 1] = arguments[i + 1].cdr
      i++
    tmp = proc.apply(null, applyArgs)
    revres = sc_cons(tmp, revres)  if tmp isnt false
  sc_reverseAppendBang revres, null

###*
META ((export #t))
###
sc_any = (proc, l) ->
  revres = null
  while l isnt null
    tmp = proc(l.car)
    return tmp  if tmp isnt false
    l = l.cdr
  false

###*
META ((export any?)
(peephole (hole 2 "sc_any(" proc "," l ") !== false")))
###
sc_anyPred = (proc, l) ->
  sc_any(proc, l) isnt false

###*
META ((export #t))
###
sc_every = (proc, l) ->
  revres = null
  tmp = true
  while l isnt null
    tmp = proc(l.car)
    return false  if tmp is false
    l = l.cdr
  tmp

###*
META ((export every?)
(peephole (hole 2 "sc_every(" proc "," l ") !== false")))
###
sc_everyPred = (proc, l) ->
  tmp = sc_every(proc, l)
  return true  if tmp isnt false
  false

###*
META ((export #t)
(peephole (postfix "()")))
###
sc_force = (o) ->
  o()

###*
META ((export #t))
###
sc_makePromise = (proc) ->
  isResultReady = false
  result = `undefined`
  ->
    unless isResultReady
      tmp = proc()
      unless isResultReady
        isResultReady = true
        result = tmp
    result
sc_Values = (values) ->
  @values = values
  return

###*
META ((export #t)
(peephole (values)))
###
sc_values = ->
  if arguments.length is 1
    arguments[0]
  else
    new sc_Values(arguments)

###*
META ((export #t))
###
sc_callWithValues = (producer, consumer) ->
  produced = producer()
  if produced instanceof sc_Values
    consumer.apply null, produced.values
  else
    consumer produced

###*
META ((export #t))
###
sc_dynamicWind = (before, thunk, after) ->
  before()
  try
    res = thunk()
    return res
  finally
    after()
  return

# TODO: eval/scheme-report-environment/null-environment/interaction-environment

# LIMITATION: 'load' doesn't exist without files.
# LIMITATION: transcript-on/transcript-off doesn't exist without files.
sc_Struct = (name) ->
  @name = name
  return

###*
META ((export #t)
(peephole (hole 1 "new sc_Struct(" name ")")))
###
sc_makeStruct = (name) ->
  new sc_Struct(name)

###*
META ((export #t)
(type bool)
(peephole (postfix " instanceof sc_Struct")))
###
sc_isStruct = (o) ->
  o instanceof sc_Struct

###*
META ((export #t)
(type bool)
(peephole (hole 2 "(" 1 " instanceof sc_Struct) && ( " 1 ".name === " 0 ")")))
###
sc_isStructNamed = (name, s) ->
  (s instanceof sc_Struct) and (s.name is name)

###*
META ((export struct-field)
(peephole (hole 3 0 "[" 2 "]")))
###
sc_getStructField = (s, name, field) ->
  s[field]

###*
META ((export struct-field-set!)
(peephole (hole 4 0 "[" 2 "] = " 3)))
###
sc_setStructFieldBang = (s, name, field, val) ->
  s[field] = val
  return

###*
META ((export #t)
(peephole (prefix "~")))
###
sc_bitNot = (x) ->
  ~x

###*
META ((export #t)
(peephole (infix 2 2 "&")))
###
sc_bitAnd = (x, y) ->
  x & y

###*
META ((export #t)
(peephole (infix 2 2 "|")))
###
sc_bitOr = (x, y) ->
  x | y

###*
META ((export #t)
(peephole (infix 2 2 "^")))
###
sc_bitXor = (x, y) ->
  x ^ y

###*
META ((export #t)
(peephole (infix 2 2 "<<")))
###
sc_bitLsh = (x, y) ->
  x << y

###*
META ((export #t)
(peephole (infix 2 2 ">>")))
###
sc_bitRsh = (x, y) ->
  x >> y

###*
META ((export #t)
(peephole (infix 2 2 ">>>")))
###
sc_bitUrsh = (x, y) ->
  x >>> y

###*
META ((export js-field js-property)
(peephole (hole 2 o "[" field "]")))
###
sc_jsField = (o, field) ->
  o[field]

###*
META ((export js-field-set! js-property-set!)
(peephole (hole 3 o "[" field "] = " val)))
###
sc_setJsFieldBang = (o, field, val) ->
  o[field] = val

###*
META ((export js-field-delete! js-property-delete!)
(peephole (hole 2 "delete" o "[" field "]")))
###
sc_deleteJsFieldBang = (o, field) ->
  delete o[field]

  return

###*
META ((export #t)
(peephole (jsCall)))
###
sc_jsCall = (o, fun) ->
  args = new Array()
  i = 2

  while i < arguments.length
    args[i - 2] = arguments[i]
    i++
  fun.apply o, args

###*
META ((export #t)
(peephole (jsMethodCall)))
###
sc_jsMethodCall = (o, field) ->
  args = new Array()
  i = 2

  while i < arguments.length
    args[i - 2] = arguments[i]
    i++
  o[field].apply o, args

###*
META ((export new js-new)
(peephole (jsNew)))
###
sc_jsNew = (c) ->
  evalStr = "new c("
  evalStr += (if arguments.length > 1 then "arguments[1]" else "")
  i = 2

  while i < arguments.length
    evalStr += ", arguments[" + i + "]"
    i++
  evalStr += ")"
  eval evalStr

# ======================== RegExp ====================
###*
META ((export #t))
###
sc_pregexp = (re) ->
  new RegExp(sc_string2jsstring(re))

###*
META ((export #t))
###
sc_pregexpMatch = (re, s) ->
  reg = (if (re instanceof RegExp) then re else sc_pregexp(re))
  tmp = reg.exec(sc_string2jsstring(s))
  return false  unless tmp?
  res = null
  i = tmp.length - 1

  while i >= 0
    if tmp[i] isnt null
      res = sc_cons(sc_jsstring2string(tmp[i]), res)
    else
      res = sc_cons(false, res)
    i--
  res

###*
META ((export #t))
###
sc_pregexpReplace = (re, s1, s2) ->
  reg = undefined
  jss1 = sc_string2jsstring(s1)
  jss2 = sc_string2jsstring(s2)
  if re instanceof RegExp
    if re.global
      reg = re
    else
      reg = new RegExp(re.source)
  else
    reg = new RegExp(sc_string2jsstring(re))
  jss1.replace reg, jss2

###*
META ((export pregexp-replace*))
###
sc_pregexpReplaceAll = (re, s1, s2) ->
  reg = undefined
  jss1 = sc_string2jsstring(s1)
  jss2 = sc_string2jsstring(s2)
  if re instanceof RegExp
    if re.global
      reg = re
    else
      reg = new RegExp(re.source, "g")
  else
    reg = new RegExp(sc_string2jsstring(re), "g")
  jss1.replace reg, jss2

###*
META ((export #t))
###
sc_pregexpSplit = (re, s) ->
  reg = ((if (re instanceof RegExp) then re else new RegExp(sc_string2jsstring(re))))
  jss = sc_string2jsstring(s)
  tmp = jss.split(reg)
  return false  unless tmp?
  sc_vector2list tmp

# =========================================================================== 

# Other library stuff 

# =========================================================================== 

###*
META ((export #t)
(peephole (hole 1 "Math.floor(Math.random()*" 'n ")")))
###
sc_random = (n) ->
  Math.floor Math.random() * n

###*
META ((export current-date)
(peephole (hole 0 "new Date()")))
###
sc_currentDate = ->
  new Date()
sc_Hashtable = ->

# sc_toWriteString == sc_toDisplayString == toString
sc_HashtableElement = (key, val) ->
  @key = key
  @val = val
  return

###*
META ((export #t)
(peephole (hole 0 "new sc_Hashtable()")))
###
sc_makeHashtable = ->
  new sc_Hashtable()

###*
META ((export #t))
###
sc_hashtablePutBang = (ht, key, val) ->
  hash = sc_hash(key)
  ht[hash] = new sc_HashtableElement(key, val)
  return

###*
META ((export #t))
###
sc_hashtableGet = (ht, key) ->
  hash = sc_hash(key)
  if hash of ht
    ht[hash].val
  else
    false

###*
META ((export #t))
###
sc_hashtableForEach = (ht, f) ->
  for v of ht
    f ht[v].key, ht[v].val  if ht[v] instanceof sc_HashtableElement
  return

###*
META ((export hashtable-contains?)
(peephole (hole 2 "sc_hash(" 1 ") in " 0)))
###
sc_hashtableContains = (ht, key) ->
  hash = sc_hash(key)
  if hash of ht
    true
  else
    false
sc_hash = (o) ->
  if o is null
    "null"
  else if o is `undefined`
    "undefined"
  else if o is true
    "true"
  else if o is false
    "false"
  else if typeof o is "number"
    "num-" + o
  else if typeof o is "string"
    "jsstr-" + o
  else if o.sc_getHash
    o.sc_getHash()
  else
    sc_counterHash.call o
sc_counterHash = ->
  unless @sc_hash
    @sc_hash = "hash-" + SC_HASH_COUNTER
    SC_HASH_COUNTER++
  @sc_hash
sc_Trampoline = (args, maxTailCalls) ->
  this["__trampoline return__"] = true
  @args = args
  @MAX_TAIL_CALLs = maxTailCalls
  return

# TODO: call/cc stuff

# set both globals.

###*
META ((export bind-exit-lambda))
###
sc_bindExitLambda = (proc) ->
  escape_obj = new sc_BindExitException()
  escape = (res) ->
    escape_obj.res = res
    throw escape_objreturn

  try
    return proc(escape)
  catch e
    return e.res  if e is escape_obj
    throw e
  return
sc_BindExitException = ->
  @_internalException = true
  return

# default tail-call depth.
# normally the program should set it again. but just in case...

# ======================== I/O =======================

#------------------------------------------------------------------
sc_EOF = ->
sc_Port = ->

# --------------- Input ports -------------------------------------
sc_InputPort = ->

# do nothing

# .............. String port ..........................
sc_ErrorInputPort = ->

# .............. String port ..........................
sc_StringInputPort = (jsStr) ->
  
  # we are going to do some charAts on the str.
  # instead of recreating all the time a String-object, we
  # create one in the beginning. (not sure, if this is really an optim)
  @str = new String(jsStr)
  @pos = 0
  return

# ------------- Read and other lib-funs  -------------------------------
sc_Token = (type, val, pos) ->
  @type = type
  @val = val
  @pos = pos
  return
#EOF
#OPEN_PAR
#CLOSE_PAR
#OPEN_BRACE
#CLOSE_BRACE
#OPEN_BRACKET
#CLOSE_BRACKET
#WHITESPACE
#QUOTE
#ID
#DOT
#STRING
#NUMBER
#ERROR
#VECTOR_BEGIN
#TRUE
#FALSE
#UNSPECIFIED
#REFERENCE
#STORE
#CHAR
sc_Tokenizer = (port) ->
  @port = port
  return
# ID-char
#STRING

# hexa-number 

# next char isn't part of hex.
#ERROR
#ERROR
#ID
#NUMBER
#DOT
#ERROR

# reference
#REFERENCE
#STORE
#ERROR
#VECTOR_BEGIN
# character
# it's escaping a whitespace char:
#ERROR
#CHAR
#CHAR
#CHAR
#ERROR

# some constants (#t, #f, #unspecified)
#TRUE
#FALSE
#UNSPECIFIED
#ERROR
#ERROR
# consume
#ERROR
#EOF
#OPEN_PAR
#CLOSE_PAR
#OPEN_BRACE
#CLOSE_BRACE
#OPEN_BRACKET
#CLOSE_BRACKET
#QUOTE
sc_Reader = (tokenizer) ->
  @tokenizer = tokenizer
  @backref = new Array()
  return
#OPEN_PAR
#CLOSE_PAR
#OPEN_BRACE
#CLOSE_BRACE
#OPEN_BRACKET
#CLOSE_BRACKET
#CLOSE_PAR
#CLOSE_BRACE
#CLOSE_BRACKET
# consume token
#EOF
#DOT
# consume token

# opening-parenthesis is already consumed
#CLOSE_PAR

# handle error
#ERROR
#OPEN_PAR
#OPEN_BRACE
#OPEN_BRACKET
#QUOTE
#STRING
#CHAR
#VECTOR_BEGIN
#REFERENCE
#STORE
#ID
#EOF
#NUMBER
#TRUE
#FALSE
#UNSPECIFIED

###*
META ((export #t))
###
sc_read = (port) ->
  # we assume the port hasn't been given.
  port = SC_DEFAULT_IN  if port is `undefined` # THREAD: shared var...
  reader = new sc_Reader(new sc_Tokenizer(port))
  reader.read()

###*
META ((export #t))
###
sc_readChar = (port) ->
  # we assume the port hasn't been given.
  port = SC_DEFAULT_IN  if port is `undefined` # THREAD: shared var...
  t = port.readChar()
  (if t is SC_EOF_OBJECT then t else new sc_Char(t))

###*
META ((export #t))
###
sc_peekChar = (port) ->
  # we assume the port hasn't been given.
  port = SC_DEFAULT_IN  if port is `undefined` # THREAD: shared var...
  t = port.peekChar()
  (if t is SC_EOF_OBJECT then t else new sc_Char(t))

###*
META ((export #t)
(type bool))
###
sc_isCharReady = (port) ->
  # we assume the port hasn't been given.
  port = SC_DEFAULT_IN  if port is `undefined` # THREAD: shared var...
  port.isCharReady()

###*
META ((export #t)
(peephole (postfix ".close()")))
###
sc_closeInputPort = (p) ->
  p.close()

###*
META ((export #t)
(type bool)
(peephole (postfix " instanceof sc_InputPort")))
###
sc_isInputPort = (o) ->
  o instanceof sc_InputPort

###*
META ((export eof-object?)
(type bool)
(peephole (postfix " === SC_EOF_OBJECT")))
###
sc_isEOFObject = (o) ->
  o is SC_EOF_OBJECT

###*
META ((export #t)
(peephole (hole 0 "SC_DEFAULT_IN")))
###
sc_currentInputPort = ->
  SC_DEFAULT_IN

# ------------ file operations are not supported -----------

###*
META ((export #t))
###
sc_callWithInputFile = (s, proc) ->
  throw "can't open " + sreturn

###*
META ((export #t))
###
sc_callWithOutputFile = (s, proc) ->
  throw "can't open " + sreturn

###*
META ((export #t))
###
sc_withInputFromFile = (s, thunk) ->
  throw "can't open " + sreturn

###*
META ((export #t))
###
sc_withOutputToFile = (s, thunk) ->
  throw "can't open " + sreturn

###*
META ((export #t))
###
sc_openInputFile = (s) ->
  throw "can't open " + sreturn

###*
META ((export #t))
###
sc_openOutputFile = (s) ->
  throw "can't open " + sreturn

# ----------------------------------------------------------------------------

###*
META ((export #t))
###
sc_basename = (p) ->
  i = p.lastIndexOf("/")
  if i >= 0
    p.substring i + 1, p.length
  else
    ""

###*
META ((export #t))
###
sc_dirname = (p) ->
  i = p.lastIndexOf("/")
  if i >= 0
    p.substring 0, i
  else
    ""

# ----------------------------------------------------------------------------

###*
META ((export #t))
###
sc_withInputFromPort = (p, thunk) ->
  try
    tmp = SC_DEFAULT_IN # THREAD: shared var.
    SC_DEFAULT_IN = p
    return thunk()
  finally
    SC_DEFAULT_IN = tmp
  return

###*
META ((export #t))
###
sc_withInputFromString = (s, thunk) ->
  sc_withInputFromPort new sc_StringInputPort(sc_string2jsstring(s)), thunk

###*
META ((export #t))
###
sc_withOutputToPort = (p, thunk) ->
  try
    tmp = SC_DEFAULT_OUT # THREAD: shared var.
    SC_DEFAULT_OUT = p
    return thunk()
  finally
    SC_DEFAULT_OUT = tmp
  return

###*
META ((export #t))
###
sc_withOutputToString = (thunk) ->
  p = new sc_StringOutputPort()
  sc_withOutputToPort p, thunk
  p.close()

###*
META ((export #t))
###
sc_withOutputToProcedure = (proc, thunk) ->
  t = (s) ->
    proc sc_jsstring2string(s)
    return

  sc_withOutputToPort new sc_GenericOutputPort(t), thunk

###*
META ((export #t)
(peephole (hole 0 "new sc_StringOutputPort()")))
###
sc_openOutputString = ->
  new sc_StringOutputPort()

###*
META ((export #t))
###
sc_openInputString = (str) ->
  new sc_StringInputPort(sc_string2jsstring(str))

# ----------------------------------------------------------------------------
sc_OutputPort = ->

# do nothing 

# do nothing 
sc_StringOutputPort = ->
  @res = ""
  return

###*
META ((export #t))
###
sc_getOutputString = (sp) ->
  sc_jsstring2string sp.res
sc_ErrorOutputPort = ->

# do nothing 
sc_GenericOutputPort = (appendJSString, close) ->
  @appendJSString = appendJSString
  @close = close  if close
  return

###*
META ((export #t)
(type bool)
(peephole (postfix " instanceof sc_OutputPort")))
###
sc_isOutputPort = (o) ->
  o instanceof sc_OutputPort

###*
META ((export #t)
(peephole (postfix ".close()")))
###
sc_closeOutputPort = (p) ->
  p.close()

# ------------------ write ---------------------------------------------------

###*
META ((export #t))
###
sc_write = (o, p) ->
  # we assume not given
  p = SC_DEFAULT_OUT  if p is `undefined`
  p.appendJSString sc_toWriteString(o)
  return
sc_toWriteString = (o) ->
  if o is null
    "()"
  else if o is true
    "#t"
  else if o is false
    "#f"
  else if o is `undefined`
    "#unspecified"
  else if typeof o is "function"
    "#<procedure " + sc_hash(o) + ">"
  else if o.sc_toWriteString
    o.sc_toWriteString()
  else
    o.toString()
sc_escapeWriteString = (s) ->
  res = ""
  j = 0
  i = 0
  while i < s.length
    switch s.charAt(i)
      when "\u0000"
        res += s.substring(j, i) + "\\0"
        j = i + 1
      when "\b"
        res += s.substring(j, i) + "\\b"
        j = i + 1
      when "\f"
        res += s.substring(j, i) + "\\f"
        j = i + 1
      when "\n"
        res += s.substring(j, i) + "\\n"
        j = i + 1
      when "\r"
        res += s.substring(j, i) + "\\r"
        j = i + 1
      when "\t"
        res += s.substring(j, i) + "\\t"
        j = i + 1
      when "\u000b"
        res += s.substring(j, i) + "\\v"
        j = i + 1
      when "\""
        res += s.substring(j, i) + "\\\""
        j = i + 1
      when "\\"
        res += s.substring(j, i) + "\\\\"
        j = i + 1
      else
        c = s.charAt(i)
        if "a" isnt "a" and c is "a"
          res += s.substring(j, i) + "\\a"
          j = i + 1
          continue
        if "\u000b" isnt "v" and c is "\u000b"
          res += s.substring(j, i) + "\\v"
          j = i + 1
          continue
        
        #if (s.charAt(i) < ' ' || s.charCodeAt(i) > 127) {
        # CARE: Manuel is this OK with HOP?
        if s.charAt(i) < " "
          
          # non printable character and special chars 
          res += s.substring(j, i) + "\\x" + s.charCodeAt(i).toString(16)
          j = i + 1
    i++
  
  # else just let i increase...
  res += s.substring(j, i)
  res

# ------------------ display ---------------------------------------------------

###*
META ((export #t))
###
sc_display = (o, p) ->
  # we assume not given
  p = SC_DEFAULT_OUT  if p is `undefined`
  p.appendJSString sc_toDisplayString(o)
  return
sc_toDisplayString = (o) ->
  if o is null
    "()"
  else if o is true
    "#t"
  else if o is false
    "#f"
  else if o is `undefined`
    "#unspecified"
  else if typeof o is "function"
    "#<procedure " + sc_hash(o) + ">"
  else if o.sc_toDisplayString
    o.sc_toDisplayString()
  else
    o.toString()

# ------------------ newline ---------------------------------------------------

###*
META ((export #t))
###
sc_newline = (p) ->
  # we assume not given
  p = SC_DEFAULT_OUT  if p is `undefined`
  p.appendJSString "\n"
  return

# ------------------ write-char ---------------------------------------------------

###*
META ((export #t))
###
sc_writeChar = (c, p) ->
  # we assume not given
  p = SC_DEFAULT_OUT  if p is `undefined`
  p.appendJSString c.val
  return

# ------------------ write-circle ---------------------------------------------------

###*
META ((export #t))
###
sc_writeCircle = (o, p) ->
  # we assume not given
  p = SC_DEFAULT_OUT  if p is `undefined`
  p.appendJSString sc_toWriteCircleString(o)
  return
sc_toWriteCircleString = (o) ->
  symb = sc_gensym("writeCircle")
  nbPointer = new Object()
  nbPointer.nb = 0
  sc_prepWriteCircle o, symb, nbPointer
  sc_genToWriteCircleString o, symb
sc_prepWriteCircle = (o, symb, nbPointer) ->
  
  # TODO sc_Struct
  if o instanceof sc_Pair or o instanceof sc_Vector
    if o[symb] isnt `undefined`
      
      # not the first visit.
      o[symb]++
      
      # unless there is already a number, assign one.
      o[symb + "nb"] = nbPointer.nb++  unless o[symb + "nb"]
      return
    o[symb] = 0
    if o instanceof sc_Pair
      sc_prepWriteCircle o.car, symb, nbPointer
      sc_prepWriteCircle o.cdr, symb, nbPointer
    else
      i = 0

      while i < o.length
        sc_prepWriteCircle o[i], symb, nbPointer
        i++
  return
sc_genToWriteCircleString = (o, symb) ->
  return sc_toWriteString(o)  unless o instanceof sc_Pair or o instanceof sc_Vector
  o.sc_toWriteCircleString symb
# use-flag is set. Just use it.
# if we are the last use. remove all fields.
# if we are the last use. remove all fields.
# implies > 0

# print car
# use-flag is set. Just use it.
# if we are the last use. remove all fields.
# if we are the last use. remove all fields.
# implies > 0

# ------------------ print ---------------------------------------------------

###*
META ((export #t))
###
sc_print = (s) ->
  if arguments.length is 1
    sc_display s
    sc_newline()
  else
    i = 0

    while i < arguments.length
      sc_display arguments[i]
      i++
    sc_newline()
  return

# ------------------ format ---------------------------------------------------

###*
META ((export #t))
###
sc_format = (s, args) ->
  len = s.length
  p = new sc_StringOutputPort()
  i = 0
  j = 1
  while i < len
    i2 = s.indexOf("~", i)
    if i2 is -1
      p.appendJSString s.substring(i, len)
      return p.close()
    else
      if i2 > i
        if i2 is (len - 1)
          p.appendJSString s.substring(i, len)
          return p.close()
        else
          p.appendJSString s.substring(i, i2)
          i = i2
      switch s.charCodeAt(i2 + 1)
        when 65, 97
          
          # a
          sc_display arguments[j], p
          i += 2
          j++
        when 83, 115
          
          # s
          sc_write arguments[j], p
          i += 2
          j++
        when 86, 118
          
          # v
          sc_display arguments[j], p
          p.appendJSString "\n"
          i += 2
          j++
        when 67, 99
          
          # c
          p.appendJSString String.fromCharCode(arguments[j])
          i += 2
          j++
        when 88, 120
          
          # x
          p.appendJSString arguments[j].toString(6)
          i += 2
          j++
        when 79, 111
          
          # o
          p.appendJSString arguments[j].toString(8)
          i += 2
          j++
        when 66, 98
          
          # b
          p.appendJSString arguments[j].toString(2)
          i += 2
          j++
        when 37, 110
          
          # %, n
          p.appendJSString "\n"
          i += 2
        when 114
          
          # r
          p.appendJSString "\r"
          i += 2
        when 126
          
          # ~
          p.appendJSString "~"
          i += 2
        else
          sc_error "format: illegal ~" + String.fromCharCode(s.charCodeAt(i2 + 1)) + " sequence"
          return ""
  p.close()

# ------------------ global ports ---------------------------------------------------

###*
META ((export #t)
(peephole (id)))
###
sc_jsstring2string = (s) ->
  s

###*
META ((export #t)
(peephole (prefix "'\\u1E9C' +")))
###
sc_jsstring2symbol = (s) ->
  sc_SYMBOL_PREFIX + s

###*
META ((export #t)
(peephole (id)))
###
sc_string2jsstring = (s) ->
  s

###*
META ((export #t)
(peephole (symbol2jsstring_immutable)))
###
sc_symbol2jsstring = (s) ->
  s.slice 1

###*
META ((export #t)
(peephole (postfix ".slice(1)")))
###
sc_keyword2jsstring = (k) ->
  k.slice 1

###*
META ((export #t)
(peephole (prefix "'\\u1E9D' +")))
###
sc_jsstring2keyword = (s) ->
  sc_KEYWORD_PREFIX + s

###*
META ((export #t)
(type bool))
###
sc_isKeyword = (s) ->
  (typeof s is "string") and (s.charAt(0) is sc_KEYWORD_PREFIX)

###*
META ((export #t))
###

###*
META ((export #t)
(type bool))
###
sc_isEqual = (o1, o2) ->
  (o1 is o2) or (sc_isPair(o1) and sc_isPair(o2) and sc_isPairEqual(o1, o2, sc_isEqual)) or (sc_isVector(o1) and sc_isVector(o2) and sc_isVectorEqual(o1, o2, sc_isEqual))

###*
META ((export number->symbol integer->symbol))
###
sc_number2symbol = (x, radix) ->
  sc_SYMBOL_PREFIX + sc_number2jsstring(x, radix)

###*
META ((export number->string integer->string))
###

###*
META ((export #t))
###
sc_symbol2number = (s, radix) ->
  sc_jsstring2number s.slice(1), radix

###*
META ((export #t))
###

###*
META ((export #t)
(peephole (prefix "+" s)))
;; peephole will only apply if no radix is given.
###
sc_string2integer = (s, radix) ->
  return +s  unless radix
  parseInt s, radix

###*
META ((export #t)
(peephole (prefix "+")))
###
sc_string2real = (s) ->
  +s

###*
META ((export #t)
(type bool))
###
sc_isSymbol = (s) ->
  (typeof s is "string") and (s.charAt(0) is sc_SYMBOL_PREFIX)

###*
META ((export #t)
(peephole (symbol2string_immutable)))
###
sc_symbol2string = (s) ->
  s.slice 1

###*
META ((export #t)
(peephole (prefix "'\\u1E9C' +")))
###
sc_string2symbol = (s) ->
  sc_SYMBOL_PREFIX + s

###*
META ((export symbol-append)
(peephole (symbolAppend_immutable)))
###
sc_symbolAppend = ->
  res = sc_SYMBOL_PREFIX
  i = 0

  while i < arguments.length
    res += arguments[i].slice(1)
    i++
  res

###*
META ((export #t)
(peephole (postfix ".val")))
###
sc_char2string = (c) ->
  c.val

###*
META ((export #t)
(peephole (hole 1 "'\\u1E9C' + " c ".val")))
###
sc_char2symbol = (c) ->
  sc_SYMBOL_PREFIX + c.val

###*
META ((export #t)
(type bool))
###
sc_isString = (s) ->
  (typeof s is "string") and (s.charAt(0) isnt sc_SYMBOL_PREFIX)

###*
META ((export #t))
###

###*
META ((export #t))
###
sc_string = ->
  i = 0

  while i < arguments.length
    arguments[i] = arguments[i].val
    i++
  "".concat.apply "", arguments

###*
META ((export #t)
(peephole (postfix ".length")))
###
sc_stringLength = (s) ->
  s.length

###*
META ((export #t))
###
sc_stringRef = (s, k) ->
  new sc_Char(s.charAt(k))

# there's no stringSet in the immutable version
#function sc_stringSet(s, k, c)
#

###*
META ((export string=?)
(type bool)
(peephole (hole 2 str1 " === " str2)))
###
sc_isStringEqual = (s1, s2) ->
  s1 is s2

###*
META ((export string<?)
(type bool)
(peephole (hole 2 str1 " < " str2)))
###
sc_isStringLess = (s1, s2) ->
  s1 < s2

###*
META ((export string>?)
(type bool)
(peephole (hole 2 str1 " > " str2)))
###
sc_isStringGreater = (s1, s2) ->
  s1 > s2

###*
META ((export string<=?)
(type bool)
(peephole (hole 2 str1 " <= " str2)))
###
sc_isStringLessEqual = (s1, s2) ->
  s1 <= s2

###*
META ((export string>=?)
(type bool)
(peephole (hole 2 str1 " >= " str2)))
###
sc_isStringGreaterEqual = (s1, s2) ->
  s1 >= s2

###*
META ((export string-ci=?)
(type bool)
(peephole (hole 2 str1 ".toLowerCase() === " str2 ".toLowerCase()")))
###
sc_isStringCIEqual = (s1, s2) ->
  s1.toLowerCase() is s2.toLowerCase()

###*
META ((export string-ci<?)
(type bool)
(peephole (hole 2 str1 ".toLowerCase() < " str2 ".toLowerCase()")))
###
sc_isStringCILess = (s1, s2) ->
  s1.toLowerCase() < s2.toLowerCase()

###*
META ((export string-ci>?)
(type bool)
(peephole (hole 2 str1 ".toLowerCase() > " str2 ".toLowerCase()")))
###
sc_isStringCIGreater = (s1, s2) ->
  s1.toLowerCase() > s2.toLowerCase()

###*
META ((export string-ci<=?)
(type bool)
(peephole (hole 2 str1 ".toLowerCase() <= " str2 ".toLowerCase()")))
###
sc_isStringCILessEqual = (s1, s2) ->
  s1.toLowerCase() <= s2.toLowerCase()

###*
META ((export string-ci>=?)
(type bool)
(peephole (hole 2 str1 ".toLowerCase() >= " str2 ".toLowerCase()")))
###
sc_isStringCIGreaterEqual = (s1, s2) ->
  s1.toLowerCase() >= s2.toLowerCase()

###*
META ((export #t)
(peephole (hole 3 s ".substring(" start ", " end ")")))
###
sc_substring = (s, start, end) ->
  s.substring start, end

###*
META ((export #t))
###
sc_isSubstring_at = (s1, s2, i) ->
  s2 is s1.substring(i, i + s2.length)

###*
META ((export #t)
(peephole (infix 0 #f "+" "''")))
###
sc_stringAppend = ->
  "".concat.apply "", arguments

###*
META ((export #t))
###

###*
META ((export #t))
###

###*
META ((export #t)
(peephole (id)))
###
sc_stringCopy = (s) ->
  s

# there's no string-fill in the immutable version
#function sc_stringFill(s, c)
#

###*
META ((export #t)
(peephole (postfix ".slice(1)")))
###
sc_keyword2string = (o) ->
  o.slice 1

###*
META ((export #t)
(peephole (prefix "'\\u1E9D' +")))
###
sc_string2keyword = (o) ->
  sc_KEYWORD_PREFIX + o

# TODO: care for symbols with spaces (escape-chars symbols).

# TODO: care for symbols with spaces (escape-chars symbols).

# Exported Variables 

# End Exports 

# Exported Variables 

# End Exports 

###*
END OF GENERATED CODE ************
###

# Invoke this function to run a benchmark.
# The first argument is a string identifying the benchmark.
# The second argument is the number of times to run the benchmark.
# The third argument is a function that runs the benchmark.
# The fourth argument is a unary function that warns if the result
# returned by the benchmark is incorrect.
#
# Example:
# RunBenchmark("new Array()",
#              1,
#              function () { new Array(1000000); }
#              function (v) {
#                return (v instanceof Array) && (v.length == 1000000);
#              });
RunBenchmark = (name, count, run, warn) ->
  n = 0

  while n < count
    result = run()
    throw new Error("Earley or Boyer did incorrect number of rewrites")  unless warn(result)
    ++n
  return
EarleyBoyer = new BenchmarkSuite("EarleyBoyer", 666463, [
  new Benchmark("Earley", ->
    BgL_earleyzd2benchmarkzd2()
    return
  )
  new Benchmark("Boyer", ->
    BgL_nboyerzd2benchmarkzd2()
    return
  )
])
sc_JS_GLOBALS = this
__sc_LINE = -1
__sc_FILE = ""
sc_properties = new Object()
sc_max = Math.max
sc_min = Math.min
sc_abs = Math.abs
sc_floor = Math.floor
sc_ceiling = Math.ceil
sc_truncate = parseInt
sc_round = Math.round
sc_exp = Math.exp
sc_log = Math.log
sc_sin = Math.sin
sc_cos = Math.cos
sc_tan = Math.tan
sc_asin = Math.asin
sc_acos = Math.acos
sc_atan = Math.atan
sc_sqrt = Math.sqrt
sc_expt = Math.pow
sc_Pair::toString = ->
  sc_toDisplayString this

sc_Pair::sc_toWriteOrDisplayString = (writeOrDisplay) ->
  current = this
  res = "("
  loop
    res += writeOrDisplay(current.car)
    if sc_isPair(current.cdr)
      res += " "
      current = current.cdr
    else if current.cdr isnt null
      res += " . " + writeOrDisplay(current.cdr)
      break
    else
      break
  res += ")"
  res

sc_Pair::sc_toDisplayString = ->
  @sc_toWriteOrDisplayString sc_toDisplayString

sc_Pair::sc_toWriteString = ->
  @sc_toWriteOrDisplayString sc_toWriteString

sc_Char.lazy = new Object()
sc_Char.char2readable =
  "\u0000": "#\\null"
  "\u0007": "#\\bell"
  "\b": "#\\backspace"
  "\t": "#\\tab"
  "\n": "#\\newline"
  "\f": "#\\page"
  "\r": "#\\return"
  "\u001b": "#\\escape"
  " ": "#\\space"
  "": "#\\delete"
  "\u0001": "#\\soh"
  "\u0002": "#\\stx"
  "\u0003": "#\\etx"
  "\u0004": "#\\eot"
  "\u0005": "#\\enq"
  "\u0006": "#\\ack"
  "\u000b": "#\\vt"
  "\u000e": "#\\so"
  "\u000f": "#\\si"
  "\u0010": "#\\dle"
  "\u0011": "#\\dc1"
  "\u0012": "#\\dc2"
  "\u0013": "#\\dc3"
  "\u0014": "#\\dc4"
  "\u0015": "#\\nak"
  "\u0016": "#\\syn"
  "\u0017": "#\\etb"
  "\u0018": "#\\can"
  "\u0019": "#\\em"
  "\u001a": "#\\sub"
  "\u001b": "#\\esc"
  "\u001c": "#\\fs"
  "\u001d": "#\\gs"
  "\u001e": "#\\rs"
  "\u001f": "#\\us"

sc_Char.readable2char =
  null: "\u0000"
  bell: "\u0007"
  backspace: "\b"
  tab: "\t"
  newline: "\n"
  page: "\f"
  return: "\r"
  escape: "\u001b"
  space: " "
  delete: "\u0000"
  soh: "\u0001"
  stx: "\u0002"
  etx: "\u0003"
  eot: "\u0004"
  enq: "\u0005"
  ack: "\u0006"
  bel: "\u0007"
  bs: "\b"
  ht: "\t"
  nl: "\n"
  vt: "\u000b"
  np: "\f"
  cr: "\r"
  so: "\u000e"
  si: "\u000f"
  dle: "\u0010"
  dc1: "\u0011"
  dc2: "\u0012"
  dc3: "\u0013"
  dc4: "\u0014"
  nak: "\u0015"
  syn: "\u0016"
  etb: "\u0017"
  can: "\u0018"
  em: "\u0019"
  sub: "\u001a"
  esc: "\u001b"
  fs: "\u001c"
  gs: "\u001d"
  rs: "\u001e"
  us: "\u001f"
  sp: " "
  del: ""

sc_Char::toString = ->
  @val

sc_Char::sc_toWriteString = ->
  entry = sc_Char.char2readable[@val]
  if entry
    entry
  else
    "#\\" + @val

sc_isCharEqual = sc_isCharStringEqual
sc_isCharLess = sc_isCharStringLess
sc_isCharGreater = sc_isCharStringGreater
sc_isCharLessEqual = sc_isCharStringLessEqual
sc_isCharGreaterEqual = sc_isCharStringGreaterEqual
sc_isCharCIEqual = sc_isCharStringCIEqual
sc_isCharCILess = sc_isCharStringCILess
sc_isCharCIGreater = sc_isCharStringCIGreater
sc_isCharCILessEqual = sc_isCharStringCILessEqual
sc_isCharCIGreaterEqual = sc_isCharStringCIGreaterEqual
SC_NUMBER_CLASS = "0123456789"
SC_WHITESPACE_CLASS = " \r\n\t\f"
SC_LOWER_CLASS = "abcdefghijklmnopqrstuvwxyz"
SC_UPPER_CLASS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
sc_Vector = Array
sc_Vector::sc_toWriteOrDisplayString = (writeOrDisplay) ->
  return "#()"  if @length is 0
  res = "#(" + writeOrDisplay(this[0])
  i = 1

  while i < @length
    res += " " + writeOrDisplay(this[i])
    i++
  res += ")"
  res

sc_Vector::sc_toDisplayString = ->
  @sc_toWriteOrDisplayString sc_toDisplayString

sc_Vector::sc_toWriteString = ->
  @sc_toWriteOrDisplayString sc_toWriteString

sc_Struct::sc_toDisplayString = ->
  "#<struct" + sc_hash(this) + ">"

sc_Struct::sc_toWriteString = sc_Struct::sc_toDisplayString
sc_Hashtable::toString = ->
  '#{%hashtable}'

SC_HASH_COUNTER = 0
sc_Trampoline::restart = ->
  o = this
  loop
    SC_TAIL_OBJECT.calls = o.MAX_TAIL_CALLs - 1
    fun = o.args.callee
    res = fun.apply(SC_TAIL_OBJECT, o.args)
    if res instanceof sc_Trampoline
      o = res
    else
      return res
  return

SC_SCM2JS_GLOBALS = new Object()
SC_TAIL_OBJECT = new Object()
SC_SCM2JS_GLOBALS.TAIL_OBJECT = SC_TAIL_OBJECT
SC_EOF_OBJECT = new sc_EOF()
sc_InputPort:: = new sc_Port()
sc_InputPort::peekChar = ->
  @peeked = @getNextChar()  unless "peeked" of this
  @peeked

sc_InputPort::readChar = ->
  tmp = @peekChar()
  delete @peeked

  tmp

sc_InputPort::isCharReady = ->
  true

sc_InputPort::close = ->

sc_ErrorInputPort:: = new sc_InputPort()
sc_ErrorInputPort::getNextChar = ->
  throw "can't read from error-port."return

sc_ErrorInputPort::isCharReady = ->
  false

sc_StringInputPort:: = new sc_InputPort()
sc_StringInputPort::getNextChar = ->
  return SC_EOF_OBJECT  if @pos >= @str.length
  @str.charAt @pos++

sc_Token.EOF = 0
sc_Token.OPEN_PAR = 1
sc_Token.CLOSE_PAR = 2
sc_Token.OPEN_BRACE = 3
sc_Token.CLOSE_BRACE = 4
sc_Token.OPEN_BRACKET = 5
sc_Token.CLOSE_BRACKET = 6
sc_Token.WHITESPACE = 7
sc_Token.QUOTE = 8
sc_Token.ID = 9
sc_Token.DOT = 10
sc_Token.STRING = 11
sc_Token.NUMBER = 12
sc_Token.ERROR = 13
sc_Token.VECTOR_BEGIN = 14
sc_Token.TRUE = 15
sc_Token.FALSE = 16
sc_Token.UNSPECIFIED = 17
sc_Token.REFERENCE = 18
sc_Token.STORE = 19
sc_Token.CHAR = 20
SC_ID_CLASS = SC_LOWER_CLASS + SC_UPPER_CLASS + "!$%*+-./:<=>?@^_~"
sc_Tokenizer::peekToken = ->
  return @peeked  if @peeked
  newToken = @nextToken()
  @peeked = newToken
  newToken

sc_Tokenizer::readToken = ->
  tmp = @peekToken()
  delete @peeked

  tmp

sc_Tokenizer::nextToken = ->
  isNumberChar = (c) ->
    c >= "0" and c <= "9"
  isIdOrNumberChar = (c) ->
    SC_ID_CLASS.indexOf(c) isnt -1 or (c >= "0" and c <= "9")
  isWhitespace = (c) ->
    c is " " or c is "\r" or c is "\n" or c is "\t" or c is "\f"
  isWhitespaceOrEOF = (c) ->
    isWhitespace(c) or c is SC_EOF_OBJECT
  readString = ->
    res = ""
    loop
      c = port.readChar()
      switch c
        when "\""
          return new sc_Token(11, res)
        when "\\"
          tmp = port.readChar()
          switch tmp
            when "0"
              res += "\u0000"
            when "a"
              res += "a"
            when "b"
              res += "\b"
            when "f"
              res += "\f"
            when "n"
              res += "\n"
            when "r"
              res += "\r"
            when "t"
              res += "\t"
            when "v"
              res += "\u000b"
            when "\""
              res += "\""
            when "\\"
              res += "\\"
            when "x"
              nb = 0
              loop
                hexC = port.peekChar()
                if hexC >= "0" and hexC <= "9"
                  port.readChar()
                  nb = nb * 16 + hexC.charCodeAt(0) - "0".charCodeAt(0)
                else if hexC >= "a" and hexC <= "f"
                  port.readChar()
                  nb = nb * 16 + hexC.charCodeAt(0) - "a".charCodeAt(0)
                else if hexC >= "A" and hexC <= "F"
                  port.readChar()
                  nb = nb * 16 + hexC.charCodeAt(0) - "A".charCodeAt(0)
                else
                  res += String.fromCharCode(nb)
                  break
            else
              return new sc_Token(13, "unclosed string-literal" + res)  if tmp is SC_EOF_OBJECT
              res += tmp
        else
          return new sc_Token(13, "unclosed string-literal" + res)  if c is SC_EOF_OBJECT
          res += c
    return
  readIdOrNumber = (firstChar) ->
    res = firstChar
    res += port.readChar()  while isIdOrNumberChar(port.peekChar())
    if isNaN(res)
      new sc_Token(9, res)
    else
      new sc_Token(12, res - 0)
  skipWhitespaceAndComments = ->
    done = false
    until done
      done = true
      port.readChar()  while isWhitespace(port.peekChar())
      if port.peekChar() is ";"
        port.readChar()
        done = false
        loop
          curChar = port.readChar()
          break  if curChar is SC_EOF_OBJECT or curChar is "\n"
    return
  readDot = ->
    if isWhitespace(port.peekChar())
      new sc_Token(10)
    else
      readIdOrNumber "."
  readSharp = ->
    c = port.readChar()
    return new sc_Token(13, "bad #-pattern0.")  if isWhitespace(c)
    if isNumberChar(c)
      nb = c - 0
      nb = nb * 10 + (port.readChar() - 0)  while isNumberChar(port.peekChar())
      switch port.readChar()
        when "#"
          return new sc_Token(18, nb)
        when "="
          return new sc_Token(19, nb)
        else
          return new sc_Token(13, "bad #-pattern1." + nb)
    return new sc_Token(14)  if c is "("
    if c is "\\"
      tmp = ""
      tmp += port.readChar()  until isWhitespaceOrEOF(port.peekChar())
      switch tmp.length
        when 0
          if sc_isEOFObject(port.peekChar)
            return new sc_Token(13, "bad #-pattern2.")
          else
            return new sc_Token(20, port.readChar())
        when 1
          return new sc_Token(20, tmp)
        else
          entry = sc_Char.readable2char[tmp.toLowerCase()]
          if entry
            return new sc_Token(20, entry)
          else
            return new sc_Token(13, "unknown character description: #\\" + tmp)
    res = undefined
    needing = undefined
    switch c
      when "t"
        res = new sc_Token(15, true)
        needing = ""
      when "f"
        res = new sc_Token(16, false)
        needing = ""
      when "u"
        res = new sc_Token(17, `undefined`)
        needing = "nspecified"
      else
        return new sc_Token(13, "bad #-pattern3: " + c)
    loop
      c = port.peekChar()
      if (isWhitespaceOrEOF(c) or c is ")") and needing is ""
        return res
      else if isWhitespace(c) or needing is ""
        return new sc_Token(13, "bad #-pattern4 " + c + " " + needing)
      else if needing.charAt(0) is c
        port.readChar()
        needing = needing.slice(1)
      else
        return new sc_Token(13, "bad #-pattern5")
    return
  port = @port
  skipWhitespaceAndComments()
  curChar = port.readChar()
  return new sc_Token(0, curChar)  if curChar is SC_EOF_OBJECT
  switch curChar
    when " ", "\n", "\t"
      readWhitespace()
    when "("
      new sc_Token(1)
    when ")"
      new sc_Token(2)
    when "{"
      new sc_Token(3)
    when "}"
      new sc_Token(4)
    when "["
      new sc_Token(5)
    when "]"
      new sc_Token(6)
    when "'"
      new sc_Token(8)
    when "#"
      readSharp()
    when "."
      readDot()
    when "\""
      readString()
    else
      return readIdOrNumber(curChar)  if isIdOrNumberChar(curChar)
      throw "unexpected character: " + curChar
  return

sc_Reader::read = ->
  readList = (listBeginType) ->
    matchesPeer = (open, close) ->
      open is 1 and close is 2 or open is 3 and close is 4 or open is 5 and close is 6
    res = null
    loop
      token = tokenizer.peekToken()
      switch token.type
        when 2, 4, 6
          if matchesPeer(listBeginType, token.type)
            tokenizer.readToken()
            return sc_reverseBang(res)
          else
            throw "closing par doesn't match: " + listBeginType + " " + listEndType
        when 0
          throw "unexpected end of file"
        when 10
          tokenizer.readToken()
          cdr = @read()
          par = tokenizer.readToken()
          unless matchesPeer(listBeginType, par.type)
            throw "closing par doesn't match: " + listBeginType + " " + par.type
          else
            return sc_reverseAppendBang(res, cdr)
        else
          res = sc_cons(@read(), res)
    return
  readQuote = ->
    sc_cons "quote", sc_cons(@read(), null)
  readVector = ->
    a = new Array()
    loop
      token = tokenizer.peekToken()
      switch token.type
        when 2
          tokenizer.readToken()
          return a
        else
          a.push @read()
    return
  storeRefence = (nb) ->
    tmp = @read()
    @backref[nb] = tmp
    tmp
  readReference = (nb) ->
    if nb of @backref
      @backref[nb]
    else
      throw "bad reference: " + nb
    return
  tokenizer = @tokenizer
  token = tokenizer.readToken()
  throw token.val  if token.type is 13
  switch token.type
    when 1, 3, 5
      readList.call this, token.type
    when 8
      readQuote.call this
    when 11
      sc_jsstring2string token.val
    when 20
      new sc_Char(token.val)
    when 14
      readVector.call this
    when 18
      readReference.call this, token.val
    when 19
      storeRefence.call this, token.val
    when 9
      sc_jsstring2symbol token.val
    when 0, 12, 15, 16, 17
      token.val
    else
      throw "unexpected token " + token.type + " " + token.val
  return

sc_OutputPort:: = new sc_Port()
sc_OutputPort::appendJSString = (obj) ->

sc_OutputPort::close = ->

sc_StringOutputPort:: = new sc_OutputPort()
sc_StringOutputPort::appendJSString = (s) ->
  @res += s
  return

sc_StringOutputPort::close = ->
  sc_jsstring2string @res

sc_ErrorOutputPort:: = new sc_OutputPort()
sc_ErrorOutputPort::appendJSString = (s) ->
  throw "don't write on ErrorPort!"return

sc_ErrorOutputPort::close = ->

sc_GenericOutputPort:: = new sc_OutputPort()
sc_Pair::sc_toWriteCircleString = (symb, inList) ->
  if this[symb + "use"]
    nb = this[symb + "nb"]
    if this[symb]-- is 0
      delete this[symb]

      delete this[symb + "nb"]

      delete this[symb + "use"]
    if inList
      return ". #" + nb + "#"
    else
      return "#" + nb + "#"
  if this[symb]-- is 0
    delete this[symb]

    delete this[symb + "nb"]

    delete this[symb + "use"]
  res = ""
  if this[symb] isnt `undefined`
    this[symb + "use"] = true
    if inList
      res += ". #" + this[symb + "nb"] + "="
    else
      res += "#" + this[symb + "nb"] + "="
    inList = false
  res += "("  unless inList
  res += sc_genToWriteCircleString(@car, symb)
  if sc_isPair(@cdr)
    res += " " + @cdr.sc_toWriteCircleString(symb, true)
  else res += " . " + sc_genToWriteCircleString(@cdr, symb)  if @cdr isnt null
  res += ")"  unless inList
  res

sc_Vector::sc_toWriteCircleString = (symb) ->
  if this[symb + "use"]
    nb = this[symb + "nb"]
    if this[symb]-- is 0
      delete this[symb]

      delete this[symb + "nb"]

      delete this[symb + "use"]
    return "#" + nb + "#"
  if this[symb]-- is 0
    delete this[symb]

    delete this[symb + "nb"]

    delete this[symb + "use"]
  res = ""
  if this[symb] isnt `undefined`
    this[symb + "use"] = true
    res += "#" + this[symb + "nb"] + "="
  res += "#("
  i = 0

  while i < @length
    res += sc_genToWriteCircleString(this[i], symb)
    res += " "  if i < @length - 1
    i++
  res += ")"
  res

SC_DEFAULT_IN = new sc_ErrorInputPort()
SC_DEFAULT_OUT = new sc_ErrorOutputPort()
SC_ERROR_OUT = new sc_ErrorOutputPort()
sc_SYMBOL_PREFIX = ""
sc_KEYWORD_PREFIX = ""
sc_gensym = ->
  counter = 1000
  (sym) ->
    counter++
    sym = sc_SYMBOL_PREFIX  unless sym
    sym + "s" + counter + "~" + "^sC-GeNsYm "
()
sc_number2string = sc_number2jsstring
sc_string2number = sc_jsstring2number
sc_makeString = sc_makejsString
sc_string2list = sc_jsstring2list
sc_list2string = sc_list2jsstring
String::sc_toDisplayString = ->
  if @charAt(0) is sc_SYMBOL_PREFIX
    @slice 1
  else if @charAt(0) is sc_KEYWORD_PREFIX
    ":" + @slice(1)
  else
    @toString()

String::sc_toWriteString = ->
  if @charAt(0) is sc_SYMBOL_PREFIX
    @slice 1
  else if @charAt(0) is sc_KEYWORD_PREFIX
    ":" + @slice(1)
  else
    "\"" + sc_escapeWriteString(this) + "\""

BgL_testzd2boyerzd2 = undefined
BgL_nboyerzd2benchmarkzd2 = undefined
BgL_setupzd2boyerzd2 = undefined
translate_term_nboyer = undefined
translate_args_nboyer = undefined
untranslate_term_nboyer = undefined
BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer = undefined
BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer = undefined
translate_alist_nboyer = undefined
apply_subst_nboyer = undefined
apply_subst_lst_nboyer = undefined
tautologyp_nboyer = undefined
if_constructor_nboyer = undefined
rewrite_count_nboyer = undefined
rewrite_nboyer = undefined
rewrite_args_nboyer = undefined
unify_subst_nboyer = undefined
one_way_unify1_nboyer = undefined
false_term_nboyer = undefined
true_term_nboyer = undefined
trans_of_implies1_nboyer = undefined
is_term_equal_nboyer = undefined
is_term_member_nboyer = undefined
const_nboyer = undefined
sc_const_3_nboyer = undefined
sc_const_4_nboyer = undefined
sc_const_4_nboyer = (new sc_Pair("implies", (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("implies", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("implies", (new sc_Pair("y", (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("implies", (new sc_Pair("z", (new sc_Pair("u", null)))))), (new sc_Pair((new sc_Pair("implies", (new sc_Pair("u", (new sc_Pair("w", null)))))), null)))))), null)))))), null)))))), (new sc_Pair((new sc_Pair("implies", (new sc_Pair("x", (new sc_Pair("w", null)))))), null))))))
sc_const_3_nboyer = sc_list((new sc_Pair("equal", (new sc_Pair((new sc_Pair("compile", (new sc_Pair("form", null)))), (new sc_Pair((new sc_Pair("reverse", (new sc_Pair((new sc_Pair("codegen", (new sc_Pair((new sc_Pair("optimize", (new sc_Pair("form", null)))), (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("eqp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("y", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("greaterp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lesseqp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("greatereqp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("boolean", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("t", null)), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("f", null)), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("iff", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("implies", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("implies", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("even1", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair((new sc_Pair("odd", (new sc_Pair((new sc_Pair("sub1", (new sc_Pair("x", null)))), null)))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("countps-", (new sc_Pair("l", (new sc_Pair("pred", null)))))), (new sc_Pair((new sc_Pair("countps-loop", (new sc_Pair("l", (new sc_Pair("pred", (new sc_Pair((new sc_Pair("zero", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("fact-", (new sc_Pair("i", null)))), (new sc_Pair((new sc_Pair("fact-loop", (new sc_Pair("i", (new sc_Pair((1), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("reverse-", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("reverse-loop", (new sc_Pair("x", (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("divides", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("zerop", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("assume-true", (new sc_Pair("var", (new sc_Pair("alist", null)))))), (new sc_Pair((new sc_Pair("cons", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("var", (new sc_Pair((new sc_Pair("t", null)), null)))))), (new sc_Pair("alist", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("assume-false", (new sc_Pair("var", (new sc_Pair("alist", null)))))), (new sc_Pair((new sc_Pair("cons", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("var", (new sc_Pair((new sc_Pair("f", null)), null)))))), (new sc_Pair("alist", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("tautology-checker", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("tautologyp", (new sc_Pair((new sc_Pair("normalize", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("falsify", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("falsify1", (new sc_Pair((new sc_Pair("normalize", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("prime", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("add1", (new sc_Pair((new sc_Pair("zero", null)), null)))), null)))))), null)))), (new sc_Pair((new sc_Pair("prime1", (new sc_Pair("x", (new sc_Pair((new sc_Pair("sub1", (new sc_Pair("x", null)))), null)))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("and", (new sc_Pair("p", (new sc_Pair("q", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("p", (new sc_Pair((new sc_Pair("if", (new sc_Pair("q", (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair((new sc_Pair("f", null)), null)))))))), (new sc_Pair((new sc_Pair("f", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("or", (new sc_Pair("p", (new sc_Pair("q", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("p", (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair((new sc_Pair("if", (new sc_Pair("q", (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair((new sc_Pair("f", null)), null)))))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("not", (new sc_Pair("p", null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("p", (new sc_Pair((new sc_Pair("f", null)), (new sc_Pair((new sc_Pair("t", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("implies", (new sc_Pair("p", (new sc_Pair("q", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("p", (new sc_Pair((new sc_Pair("if", (new sc_Pair("q", (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair((new sc_Pair("f", null)), null)))))))), (new sc_Pair((new sc_Pair("t", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("x", null)))), (new sc_Pair("x", (new sc_Pair((new sc_Pair("zero", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("if", (new sc_Pair("a", (new sc_Pair("b", (new sc_Pair("c", null)))))))), (new sc_Pair("d", (new sc_Pair("e", null)))))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("a", (new sc_Pair((new sc_Pair("if", (new sc_Pair("b", (new sc_Pair("d", (new sc_Pair("e", null)))))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair("c", (new sc_Pair("d", (new sc_Pair("e", null)))))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("x", null)))), null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("a", null)))), (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("b", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair("x", (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("fix", (new sc_Pair("b", null)))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("c", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair((new sc_Pair("difference", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("difference", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair("x", null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair("y", null)))), (new sc_Pair("a", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair((new sc_Pair("plus-fringe", (new sc_Pair("x", null)))), null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair("x", (new sc_Pair("a", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair((new sc_Pair("append", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), null)))), (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("b", null)))), (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("a", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("z", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("exec", (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("pds", (new sc_Pair("envrn", null)))))))), (new sc_Pair((new sc_Pair("exec", (new sc_Pair("y", (new sc_Pair((new sc_Pair("exec", (new sc_Pair("x", (new sc_Pair("pds", (new sc_Pair("envrn", null)))))))), (new sc_Pair("envrn", null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("mc-flatten", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("x", null)))), (new sc_Pair("y", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), null)))))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair("b", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("y", null)))), null)))))), (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("length", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("length", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("member", (new sc_Pair("a", (new sc_Pair((new sc_Pair("intersect", (new sc_Pair("b", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("member", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("member", (new sc_Pair("a", (new sc_Pair("c", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("nth", (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("exp", (new sc_Pair("i", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("j", (new sc_Pair("k", null)))))), null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair((new sc_Pair("exp", (new sc_Pair("i", (new sc_Pair("j", null)))))), (new sc_Pair((new sc_Pair("exp", (new sc_Pair("i", (new sc_Pair("k", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("exp", (new sc_Pair("i", (new sc_Pair((new sc_Pair("times", (new sc_Pair("j", (new sc_Pair("k", null)))))), null)))))), (new sc_Pair((new sc_Pair("exp", (new sc_Pair((new sc_Pair("exp", (new sc_Pair("i", (new sc_Pair("j", null)))))), (new sc_Pair("k", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("reverse-loop", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("x", null)))), (new sc_Pair("y", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("reverse-loop", (new sc_Pair("x", (new sc_Pair((new sc_Pair("nil", null)), null)))))), (new sc_Pair((new sc_Pair("reverse", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("count-list", (new sc_Pair("z", (new sc_Pair((new sc_Pair("sort-lp", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("count-list", (new sc_Pair("z", (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("count-list", (new sc_Pair("z", (new sc_Pair("y", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("b", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair((new sc_Pair("quotient", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair((new sc_Pair("big-plus1", (new sc_Pair("l", (new sc_Pair("i", (new sc_Pair("base", null)))))))), (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair("l", (new sc_Pair("base", null)))))), (new sc_Pair("i", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair((new sc_Pair("big-plus", (new sc_Pair("x", (new sc_Pair("y", (new sc_Pair("i", (new sc_Pair("base", null)))))))))), (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("i", (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair("x", (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair("y", (new sc_Pair("base", null)))))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("y", (new sc_Pair((1), null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("x", (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("quotient", (new sc_Pair("i", (new sc_Pair("j", null)))))), (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("i", null)))), null)))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("j", null)))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("j", (new sc_Pair((1), null)))))), null)))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), null)))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair((new sc_Pair("power-rep", (new sc_Pair("i", (new sc_Pair("base", null)))))), (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("i", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("power-eval", (new sc_Pair((new sc_Pair("big-plus", (new sc_Pair((new sc_Pair("power-rep", (new sc_Pair("i", (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("power-rep", (new sc_Pair("j", (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair("base", null)))))))))), (new sc_Pair("base", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("i", (new sc_Pair("j", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("gcd", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("gcd", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("nth", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("nth", (new sc_Pair("a", (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("nth", (new sc_Pair("b", (new sc_Pair((new sc_Pair("difference", (new sc_Pair("i", (new sc_Pair((new sc_Pair("length", (new sc_Pair("a", null)))), null)))))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("y", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("y", (new sc_Pair("x", null)))))), (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("y", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("difference", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair((new sc_Pair("difference", (new sc_Pair("c", (new sc_Pair("w", null)))))), null)))))), (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("times", (new sc_Pair("c", (new sc_Pair("x", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("w", (new sc_Pair("x", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("z", null)))))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("b", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("b", (new sc_Pair("c", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("add1", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("add1", (new sc_Pair("y", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("z", null)))), null)))), (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("x", null)))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("gcd", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("times", (new sc_Pair("z", (new sc_Pair((new sc_Pair("gcd", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("value", (new sc_Pair((new sc_Pair("normalize", (new sc_Pair("x", null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("value", (new sc_Pair("x", (new sc_Pair("a", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("cons", (new sc_Pair("y", (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("nlistp", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("listp", (new sc_Pair((new sc_Pair("gopher", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("listp", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("samefringe", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("y", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("greatest-factor", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("y", (new sc_Pair((1), null)))))), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("zero", null)), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("greatest-factor", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((1), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((1), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair((new sc_Pair("greatest-factor", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("y", (new sc_Pair((1), null)))))), null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("x", null)))), null)))), null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("times-list", (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair((new sc_Pair("times", (new sc_Pair((new sc_Pair("times-list", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("times-list", (new sc_Pair("y", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("prime-list", (new sc_Pair((new sc_Pair("append", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("prime-list", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("prime-list", (new sc_Pair("y", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("z", (new sc_Pair((new sc_Pair("times", (new sc_Pair("w", (new sc_Pair("z", null)))))), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("z", null)))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("z", (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("w", (new sc_Pair((1), null)))))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("greatereqp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("or", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("x", (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair((new sc_Pair("and", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair("y", (new sc_Pair((1), null)))))), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair("x", null)))))), (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((1), null)))))), (new sc_Pair(sc_list("and", (new sc_Pair("not", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("a", (new sc_Pair((new sc_Pair("zero", null)), null)))))), null)))), (new sc_Pair("not", (new sc_Pair((new sc_Pair("equal", (new sc_Pair("b", (new sc_Pair((new sc_Pair("zero", null)), null)))))), null)))), (new sc_Pair("numberp", (new sc_Pair("a", null)))), (new sc_Pair("numberp", (new sc_Pair("b", null)))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("sub1", (new sc_Pair("a", null)))), (new sc_Pair((new sc_Pair("zero", null)), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("sub1", (new sc_Pair("b", null)))), (new sc_Pair((new sc_Pair("zero", null)), null))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair((new sc_Pair("length", (new sc_Pair((new sc_Pair("delete", (new sc_Pair("x", (new sc_Pair("l", null)))))), null)))), (new sc_Pair((new sc_Pair("length", (new sc_Pair("l", null)))), null)))))), (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair("l", null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("sort2", (new sc_Pair((new sc_Pair("delete", (new sc_Pair("x", (new sc_Pair("l", null)))))), null)))), (new sc_Pair((new sc_Pair("delete", (new sc_Pair("x", (new sc_Pair((new sc_Pair("sort2", (new sc_Pair("l", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("dsort", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("sort2", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("length", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x1", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x2", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x3", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x4", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x5", (new sc_Pair((new sc_Pair("cons", (new sc_Pair("x6", (new sc_Pair("x7", null)))))), null)))))), null)))))), null)))))), null)))))), null)))))), null)))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair((6), (new sc_Pair((new sc_Pair("length", (new sc_Pair("x7", null)))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("add1", (new sc_Pair((new sc_Pair("add1", (new sc_Pair("x", null)))), null)))), (new sc_Pair((2), null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("quotient", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((2), null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair((new sc_Pair("quotient", (new sc_Pair("y", (new sc_Pair((2), null)))))), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("sigma", (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("quotient", (new sc_Pair((new sc_Pair("times", (new sc_Pair("i", (new sc_Pair((new sc_Pair("add1", (new sc_Pair("i", null)))), null)))))), (new sc_Pair((2), null)))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair((new sc_Pair("add1", (new sc_Pair("y", null)))), null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("y", null)))), (new sc_Pair((new sc_Pair("add1", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair((new sc_Pair("add1", (new sc_Pair("x", null)))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("difference", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("difference", (new sc_Pair("z", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("z", null)))))), null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("z", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("not", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("y", (new sc_Pair("x", null)))))), null)))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("z", null)))), null)))))), null)))))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair((new sc_Pair("delete", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("member", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("difference", (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair("y", null)))), (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("meaning", (new sc_Pair("x", (new sc_Pair("a", null)))))), null)))))), (new sc_Pair((new sc_Pair("meaning", (new sc_Pair((new sc_Pair("plus-tree", (new sc_Pair("y", null)))), (new sc_Pair("a", null)))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair((new sc_Pair("add1", (new sc_Pair("y", null)))), null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("numberp", (new sc_Pair("y", null)))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("x", (new sc_Pair((new sc_Pair("times", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("nth", (new sc_Pair((new sc_Pair("nil", null)), (new sc_Pair("i", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("i", null)))), (new sc_Pair((new sc_Pair("nil", null)), (new sc_Pair((new sc_Pair("zero", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("last", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("listp", (new sc_Pair("b", null)))), (new sc_Pair((new sc_Pair("last", (new sc_Pair("b", null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("listp", (new sc_Pair("a", null)))), (new sc_Pair((new sc_Pair("cons", (new sc_Pair((new sc_Pair("car", (new sc_Pair((new sc_Pair("last", (new sc_Pair("a", null)))), null)))), (new sc_Pair("b", null)))))), (new sc_Pair("b", null)))))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("lessp", (new sc_Pair("x", (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("t", null)), (new sc_Pair("z", null)))))), (new sc_Pair((new sc_Pair("equal", (new sc_Pair((new sc_Pair("f", null)), (new sc_Pair("z", null)))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("assignment", (new sc_Pair("x", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("assignedp", (new sc_Pair("x", (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("assignment", (new sc_Pair("x", (new sc_Pair("a", null)))))), (new sc_Pair((new sc_Pair("assignment", (new sc_Pair("x", (new sc_Pair("b", null)))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("car", (new sc_Pair((new sc_Pair("gopher", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("listp", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("car", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("zero", null)), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair((new sc_Pair("cdr", (new sc_Pair((new sc_Pair("gopher", (new sc_Pair("x", null)))), null)))), null)))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("listp", (new sc_Pair("x", null)))), (new sc_Pair((new sc_Pair("cdr", (new sc_Pair((new sc_Pair("flatten", (new sc_Pair("x", null)))), null)))), (new sc_Pair((new sc_Pair("cons", (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("quotient", (new sc_Pair((new sc_Pair("times", (new sc_Pair("y", (new sc_Pair("x", null)))))), (new sc_Pair("y", null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("zerop", (new sc_Pair("y", null)))), (new sc_Pair((new sc_Pair("zero", null)), (new sc_Pair((new sc_Pair("fix", (new sc_Pair("x", null)))), null)))))))), null)))))), (new sc_Pair("equal", (new sc_Pair((new sc_Pair("get", (new sc_Pair("j", (new sc_Pair((new sc_Pair("set", (new sc_Pair("i", (new sc_Pair("val", (new sc_Pair("mem", null)))))))), null)))))), (new sc_Pair((new sc_Pair("if", (new sc_Pair((new sc_Pair("eqp", (new sc_Pair("j", (new sc_Pair("i", null)))))), (new sc_Pair("val", (new sc_Pair((new sc_Pair("get", (new sc_Pair("j", (new sc_Pair("mem", null)))))), null)))))))), null)))))))
const_nboyer = (new sc_Pair((new sc_Pair("x", (new sc_Pair("f", (new sc_Pair((new sc_Pair("plus", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("c", (new sc_Pair((new sc_Pair("zero", null)), null)))))), null)))))), null)))))), (new sc_Pair((new sc_Pair("y", (new sc_Pair("f", (new sc_Pair((new sc_Pair("times", (new sc_Pair((new sc_Pair("times", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("plus", (new sc_Pair("c", (new sc_Pair("d", null)))))), null)))))), null)))))), (new sc_Pair((new sc_Pair("z", (new sc_Pair("f", (new sc_Pair((new sc_Pair("reverse", (new sc_Pair((new sc_Pair("append", (new sc_Pair((new sc_Pair("append", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("nil", null)), null)))))), null)))), null)))))), (new sc_Pair((new sc_Pair("u", (new sc_Pair("equal", (new sc_Pair((new sc_Pair("plus", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("difference", (new sc_Pair("x", (new sc_Pair("y", null)))))), null)))))))), (new sc_Pair((new sc_Pair("w", (new sc_Pair("lessp", (new sc_Pair((new sc_Pair("remainder", (new sc_Pair("a", (new sc_Pair("b", null)))))), (new sc_Pair((new sc_Pair("member", (new sc_Pair("a", (new sc_Pair((new sc_Pair("length", (new sc_Pair("b", null)))), null)))))), null)))))))), null))))))))))
BgL_nboyerzd2benchmarkzd2 = ->
  args = null
  sc_tmp = arguments.length - 1

  while sc_tmp >= 0
    args = sc_cons(arguments[sc_tmp], args)
    sc_tmp--
  n = undefined
  (n = ((if (args is null) then (0) else (args.car))))
  (BgL_setupzd2boyerzd2())
  (BgL_runzd2benchmarkzd2(("nboyer" + (sc_number2string(n))), (1), ->
    BgL_testzd2boyerzd2 n
  , (rewrites) ->
    if sc_isNumber(rewrites)
      switch n
        when (0)
          return (rewrites is (95024))
        when (1)
          return (rewrites is (591777))
        when (2)
          return (rewrites is (1813975))
        when (3)
          return (rewrites is (5375678))
        when (4)
          return (rewrites is (16445406))
        when (5)
          return (rewrites is (51507739))
        else
          return true
    else
      false
  ))

BgL_setupzd2boyerzd2 = ->
  true

BgL_testzd2boyerzd2 = ->
  true

translate_term_nboyer = (term) ->
  lst = undefined
  (if (term not instanceof sc_Pair) then term else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((term.car))), ((lst = (term.cdr))
  ((if (lst is null) then null else (new sc_Pair((translate_term_nboyer((lst.car))), (translate_args_nboyer((lst.cdr)))))))
  ))))

translate_args_nboyer = (lst) ->
  sc_lst_5 = undefined
  term = undefined
  (if (lst is null) then null else (new sc_Pair(((term = (lst.car))
  ((if (term not instanceof sc_Pair) then term else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((term.car))), (translate_args_nboyer((term.cdr)))))))
  ), ((sc_lst_5 = (lst.cdr))
  ((if (sc_lst_5 is null) then null else (new sc_Pair((translate_term_nboyer((sc_lst_5.car))), (translate_args_nboyer((sc_lst_5.cdr)))))))
  ))))

untranslate_term_nboyer = (term) ->
  optrOpnd = undefined
  tail1131 = undefined
  L1127 = undefined
  falseHead1130 = undefined
  symbol_record = undefined
  unless term instanceof sc_Pair
    term
  else
    falseHead1130 = (new sc_Pair(null, null))
    L1127 = (term.cdr)
    tail1131 = falseHead1130
    until (L1127 is null)
      tail1131.cdr = (new sc_Pair((untranslate_term_nboyer((L1127.car))), null))
      tail1131 = (tail1131.cdr)
      L1127 = (L1127.cdr)
    optrOpnd = (falseHead1130.cdr)
    new sc_Pair(((symbol_record = (term.car))
    (symbol_record[(0)])
    ), optrOpnd)

BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer = (sym) ->
  r = undefined
  x = undefined
  (x = (sc_assq(sym, BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer)))
  ((if (x isnt false) then (x.cdr) else ((r = [
    sym
    null
  ])
  (BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer = (new sc_Pair((new sc_Pair(sym, r)), BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer)))
  r
  )))

BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer = null
translate_alist_nboyer = (alist) ->
  sc_alist_6 = undefined
  term = undefined
  (if (alist is null) then null else (new sc_Pair((new sc_Pair((alist.car.car), ((term = (alist.car.cdr))
  ((if (term not instanceof sc_Pair) then term else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((term.car))), (translate_args_nboyer((term.cdr)))))))
  ))), ((sc_alist_6 = (alist.cdr))
  ((if (sc_alist_6 is null) then null else (new sc_Pair((new sc_Pair((sc_alist_6.car.car), (translate_term_nboyer((sc_alist_6.car.cdr))))), (translate_alist_nboyer((sc_alist_6.cdr)))))))
  ))))

apply_subst_nboyer = (alist, term) ->
  lst = undefined
  temp_temp = undefined
  (if (term not instanceof sc_Pair) then ((temp_temp = (sc_assq(term, alist)))
  ((if (temp_temp isnt false) then (temp_temp.cdr) else term))
  ) else (new sc_Pair((term.car), ((lst = (term.cdr))
  ((if (lst is null) then null else (new sc_Pair((apply_subst_nboyer(alist, (lst.car))), (apply_subst_lst_nboyer(alist, (lst.cdr)))))))
  ))))

apply_subst_lst_nboyer = (alist, lst) ->
  sc_lst_7 = undefined
  (if (lst is null) then null else (new sc_Pair((apply_subst_nboyer(alist, (lst.car))), ((sc_lst_7 = (lst.cdr))
  ((if (sc_lst_7 is null) then null else (new sc_Pair((apply_subst_nboyer(alist, (sc_lst_7.car))), (apply_subst_lst_nboyer(alist, (sc_lst_7.cdr)))))))
  ))))

tautologyp_nboyer = (sc_x_11, true_lst, false_lst) ->
  tmp1125 = undefined
  x = undefined
  tmp1126 = undefined
  sc_x_8 = undefined
  sc_tmp1125_9 = undefined
  sc_tmp1126_10 = undefined
  sc_x_11 = undefined
  true_lst = undefined
  false_lst = undefined
  loop
    if ((sc_tmp1126_10 = (is_term_equal_nboyer(sc_x_11, true_term_nboyer)))
    ((if (sc_tmp1126_10 isnt false) then sc_tmp1126_10 else (is_term_member_nboyer(sc_x_11, true_lst))))
    ) isnt false
      return true
    else if ((sc_tmp1125_9 = (is_term_equal_nboyer(sc_x_11, false_term_nboyer)))
    ((if (sc_tmp1125_9 isnt false) then sc_tmp1125_9 else (is_term_member_nboyer(sc_x_11, false_lst))))
    ) isnt false
      return false
    else unless sc_x_11 instanceof sc_Pair
      return false
    else if (sc_x_11.car) is if_constructor_nboyer
      if ((sc_x_8 = (sc_x_11.cdr.car))
      (tmp1126 = (is_term_equal_nboyer(sc_x_8, true_term_nboyer)))
      ((if (tmp1126 isnt false) then tmp1126 else (is_term_member_nboyer(sc_x_8, true_lst))))
      ) isnt false
        sc_x_11 = (sc_x_11.cdr.cdr.car)
      else if ((x = (sc_x_11.cdr.car))
      (tmp1125 = (is_term_equal_nboyer(x, false_term_nboyer)))
      ((if (tmp1125 isnt false) then tmp1125 else (is_term_member_nboyer(x, false_lst))))
      ) isnt false
        sc_x_11 = (sc_x_11.cdr.cdr.cdr.car)
      else if (tautologyp_nboyer((sc_x_11.cdr.cdr.car), (new sc_Pair((sc_x_11.cdr.car), true_lst)), false_lst)) isnt false
        false_lst = (new sc_Pair((sc_x_11.cdr.car), false_lst))
        sc_x_11 = (sc_x_11.cdr.cdr.cdr.car)
      else
        return false
    else
      return false
  return

if_constructor_nboyer = "*"
rewrite_count_nboyer = (0)
rewrite_nboyer = (term) ->
  term2 = undefined
  sc_term_12 = undefined
  lst = undefined
  symbol_record = undefined
  sc_lst_13 = undefined
  ++rewrite_count_nboyer
  unless term instanceof sc_Pair
    term
  else
    sc_term_12 = (new sc_Pair((term.car), ((sc_lst_13 = (term.cdr))
    ((if (sc_lst_13 is null) then null else (new sc_Pair((rewrite_nboyer((sc_lst_13.car))), (rewrite_args_nboyer((sc_lst_13.cdr)))))))
    )))
    lst = ((symbol_record = (term.car))
    (symbol_record[(1)])
    )
    loop
      if lst is null
        return sc_term_12
      else if ((term2 = ((lst.car).cdr.car))
      (unify_subst_nboyer = null)
      (one_way_unify1_nboyer(sc_term_12, term2))
      ) isnt false
        return (rewrite_nboyer((apply_subst_nboyer(unify_subst_nboyer, ((lst.car).cdr.cdr.car)))))
      else
        lst = (lst.cdr)
  return

rewrite_args_nboyer = (lst) ->
  sc_lst_14 = undefined
  (if (lst is null) then null else (new sc_Pair((rewrite_nboyer((lst.car))), ((sc_lst_14 = (lst.cdr))
  ((if (sc_lst_14 is null) then null else (new sc_Pair((rewrite_nboyer((sc_lst_14.car))), (rewrite_args_nboyer((sc_lst_14.cdr)))))))
  ))))

unify_subst_nboyer = "*"
one_way_unify1_nboyer = (term1, term2) ->
  lst1 = undefined
  lst2 = undefined
  temp_temp = undefined
  unless term2 instanceof sc_Pair
    temp_temp = (sc_assq(term2, unify_subst_nboyer))
    if temp_temp isnt false
      is_term_equal_nboyer term1, (temp_temp.cdr)
    else if sc_isNumber(term2)
      sc_isEqual term1, term2
    else
      unify_subst_nboyer = (new sc_Pair((new sc_Pair(term2, term1)), unify_subst_nboyer))
      true
  else unless term1 instanceof sc_Pair
    false
  else if (term1.car) is (term2.car)
    lst1 = (term1.cdr)
    lst2 = (term2.cdr)
    loop
      if lst1 is null
        return (lst2 is null)
      else if lst2 is null
        return false
      else if (one_way_unify1_nboyer((lst1.car), (lst2.car))) isnt false
        lst1 = (lst1.cdr)
        lst2 = (lst2.cdr)
      else
        return false
  else
    false
  return

false_term_nboyer = "*"
true_term_nboyer = "*"
trans_of_implies1_nboyer = (n) ->
  sc_n_15 = undefined
  (if (sc_isEqual(n, (1))) then (sc_list("implies", (0), (1))) else (sc_list("and", (sc_list("implies", (n - (1)), n)), ((sc_n_15 = (n - (1)))
  ((if (sc_isEqual(sc_n_15, (1))) then (sc_list("implies", (0), (1))) else (sc_list("and", (sc_list("implies", (sc_n_15 - (1)), sc_n_15)), (trans_of_implies1_nboyer((sc_n_15 - (1))))))))
  ))))

is_term_equal_nboyer = (x, y) ->
  lst1 = undefined
  lst2 = undefined
  r2 = undefined
  r1 = undefined
  if x instanceof sc_Pair
    if y instanceof sc_Pair
      if ((r1 = (x.car))
      (r2 = (y.car))
      (r1 is r2)
      ) isnt false
        lst1 = (x.cdr)
        lst2 = (y.cdr)
        loop
          if lst1 is null
            return (lst2 is null)
          else if lst2 is null
            return false
          else if (is_term_equal_nboyer((lst1.car), (lst2.car))) isnt false
            lst1 = (lst1.cdr)
            lst2 = (lst2.cdr)
          else
            return false
      else
        false
    else
      false
  else
    sc_isEqual x, y
  return

is_term_member_nboyer = (x, lst) ->
  x = undefined
  lst = undefined
  loop
    if lst is null
      return false
    else if (is_term_equal_nboyer(x, (lst.car))) isnt false
      return true
    else
      lst = (lst.cdr)
  return

BgL_setupzd2boyerzd2 = ->
  symbol_record = undefined
  value = undefined
  BgL_sc_symbolzd2record_16zd2 = undefined
  sym = undefined
  sc_sym_17 = undefined
  term = undefined
  lst = undefined
  sc_term_18 = undefined
  sc_term_19 = undefined
  BgL_sc_za2symbolzd2recordszd2alistza2_2z00_nboyer = null
  if_constructor_nboyer = (BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer("if"))
  false_term_nboyer = ((sc_term_19 = (new sc_Pair("f", null)))
  ((if (sc_term_19 not instanceof sc_Pair) then sc_term_19 else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((sc_term_19.car))), (translate_args_nboyer((sc_term_19.cdr)))))))
  )
  true_term_nboyer = ((sc_term_18 = (new sc_Pair("t", null)))
  ((if (sc_term_18 not instanceof sc_Pair) then sc_term_18 else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((sc_term_18.car))), (translate_args_nboyer((sc_term_18.cdr)))))))
  )
  lst = sc_const_3_nboyer
  until (lst is null)
    term = (lst.car)
    if (term instanceof sc_Pair) and (((term.car) is "equal") and ((term.cdr.car) instanceof sc_Pair))
      sc_sym_17 = ((term.cdr.car).car)
      value = (new sc_Pair(((if (term instanceof sc_Pair) then term else (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((term.car))), (translate_args_nboyer((term.cdr))))))), ((sym = ((term.cdr.car).car))
      (BgL_sc_symbolzd2record_16zd2 = (BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer(sym)))
      (BgL_sc_symbolzd2record_16zd2[(1)])
      )))
      symbol_record = (BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer(sc_sym_17))
      symbol_record[(1)] = value
    else
      sc_error "ADD-LEMMA did not like term:  ", term
    lst = (lst.cdr)
  true

BgL_testzd2boyerzd2 = (n) ->
  optrOpnd = undefined
  term = undefined
  sc_n_20 = undefined
  answer = undefined
  sc_term_21 = undefined
  sc_term_22 = undefined
  rewrite_count_nboyer = (0)
  term = sc_const_4_nboyer
  sc_n_20 = n
  until (sc_n_20 is 0)
    term = (sc_list("or", term, (new sc_Pair("f", null))))
    --sc_n_20
  sc_term_22 = term
  unless sc_term_22 instanceof sc_Pair
    optrOpnd = sc_term_22
  else
    optrOpnd = (new sc_Pair((BgL_sc_symbolzd2ze3symbolzd2record_1ze3_nboyer((sc_term_22.car))), (translate_args_nboyer((sc_term_22.cdr)))))
  sc_term_21 = (apply_subst_nboyer(((if (const_nboyer is null) then null else (new sc_Pair((new sc_Pair((const_nboyer.car.car), (translate_term_nboyer((const_nboyer.car.cdr))))), (translate_alist_nboyer((const_nboyer.cdr))))))), optrOpnd))
  answer = (tautologyp_nboyer((rewrite_nboyer(sc_term_21)), null, null))
  sc_write rewrite_count_nboyer
  sc_display " rewrites"
  sc_newline()
  if answer isnt false
    rewrite_count_nboyer
  else
    false

BgL_parsezd2ze3nbzd2treesze3 = undefined
BgL_earleyzd2benchmarkzd2 = undefined
BgL_parsezd2ze3parsedzf3zc2 = undefined
test = undefined
BgL_parsezd2ze3treesz31 = undefined
BgL_makezd2parserzd2 = undefined
const_earley = undefined
const_earley = (new sc_Pair((new sc_Pair("s", (new sc_Pair((new sc_Pair("a", null)), (new sc_Pair((new sc_Pair("s", (new sc_Pair("s", null)))), null)))))), null))
BgL_makezd2parserzd2 = (grammar, lexer) ->
  i = undefined
  parser_descr = undefined
  def_loop = undefined
  nb_nts = undefined
  names = undefined
  steps = undefined
  predictors = undefined
  enders = undefined
  starters = undefined
  nts = undefined
  sc_names_1 = undefined
  sc_steps_2 = undefined
  sc_predictors_3 = undefined
  sc_enders_4 = undefined
  sc_starters_5 = undefined
  nb_confs = undefined
  BgL_sc_defzd2loop_6zd2 = undefined
  BgL_sc_nbzd2nts_7zd2 = undefined
  sc_nts_8 = undefined
  BgL_sc_defzd2loop_9zd2 = undefined
  ind = undefined
  ind = (nt, sc_nts_10) ->
    i = undefined
    i = ((sc_nts_10.length) - (1))
    loop
      if i >= (0)
        if sc_isEqual((sc_nts_10[i]), nt)
          return i
        else
          --i
      else
        return false
    return

  sc_nts_8 = ((BgL_sc_defzd2loop_9zd2 = (defs, sc_nts_11) ->
    rule_loop = undefined
    head = undefined
    def = undefined
    (if (defs instanceof sc_Pair) then ((def = (defs.car))
    (head = (def.car))
    (rule_loop = (rules, sc_nts_12) ->
      nt = undefined
      l = undefined
      sc_nts_13 = undefined
      rule = undefined
      if rules instanceof sc_Pair
        rule = (rules.car)
        l = rule
        sc_nts_13 = sc_nts_12
        while (l instanceof sc_Pair)
          nt = (l.car)
          l = (l.cdr)
          sc_nts_13 = ((if ((sc_member(nt, sc_nts_13)) isnt false) then sc_nts_13 else (new sc_Pair(nt, sc_nts_13))))
        rule_loop (rules.cdr), sc_nts_13
      else
        BgL_sc_defzd2loop_9zd2 (defs.cdr), sc_nts_12
    )
    (rule_loop((def.cdr), ((if ((sc_member(head, sc_nts_11)) isnt false) then sc_nts_11 else (new sc_Pair(head, sc_nts_11))))))
    ) else (sc_list2vector((sc_reverse(sc_nts_11)))))
  )
  (BgL_sc_defzd2loop_9zd2(grammar, null))
  )
  BgL_sc_nbzd2nts_7zd2 = (sc_nts_8.length)
  nb_confs = (((BgL_sc_defzd2loop_6zd2 = (defs, BgL_sc_nbzd2confs_14zd2) ->
    rule_loop = undefined
    def = undefined
    (if (defs instanceof sc_Pair) then ((def = (defs.car))
    (rule_loop = (rules, BgL_sc_nbzd2confs_15zd2) ->
      l = undefined
      BgL_sc_nbzd2confs_16zd2 = undefined
      rule = undefined
      if rules instanceof sc_Pair
        rule = (rules.car)
        l = rule
        BgL_sc_nbzd2confs_16zd2 = BgL_sc_nbzd2confs_15zd2
        while (l instanceof sc_Pair)
          l = (l.cdr)
          ++BgL_sc_nbzd2confs_16zd2
        rule_loop (rules.cdr), (BgL_sc_nbzd2confs_16zd2 + (1))
      else
        BgL_sc_defzd2loop_6zd2 (defs.cdr), BgL_sc_nbzd2confs_15zd2
    )
    (rule_loop((def.cdr), BgL_sc_nbzd2confs_14zd2))
    ) else BgL_sc_nbzd2confs_14zd2)
  )
  (BgL_sc_defzd2loop_6zd2(grammar, (0)))
  ) + BgL_sc_nbzd2nts_7zd2)
  sc_starters_5 = (sc_makeVector(BgL_sc_nbzd2nts_7zd2, null))
  sc_enders_4 = (sc_makeVector(BgL_sc_nbzd2nts_7zd2, null))
  sc_predictors_3 = (sc_makeVector(BgL_sc_nbzd2nts_7zd2, null))
  sc_steps_2 = (sc_makeVector(nb_confs, false))
  sc_names_1 = (sc_makeVector(nb_confs, false))
  nts = sc_nts_8
  starters = sc_starters_5
  enders = sc_enders_4
  predictors = sc_predictors_3
  steps = sc_steps_2
  names = sc_names_1
  nb_nts = (sc_nts_8.length)
  i = (nb_nts - (1))
  while (i >= (0))
    sc_steps_2[i] = (i - nb_nts)
    sc_names_1[i] = (sc_list((sc_nts_8[i]), (0)))
    sc_enders_4[i] = (sc_list(i))
    --i
  def_loop = (defs, conf) ->
    rule_loop = undefined
    head = undefined
    def = undefined
    (if (defs instanceof sc_Pair) then ((def = (defs.car))
    (head = (def.car))
    (rule_loop = (rules, conf, rule_num) ->
      i = undefined
      sc_i_17 = undefined
      nt = undefined
      l = undefined
      sc_conf_18 = undefined
      sc_i_19 = undefined
      rule = undefined
      if rules instanceof sc_Pair
        rule = (rules.car)
        names[conf] = (sc_list(head, rule_num))
        sc_i_19 = (ind(head, nts))
        starters[sc_i_19] = (new sc_Pair(conf, (starters[sc_i_19])))
        l = rule
        sc_conf_18 = conf
        while (l instanceof sc_Pair)
          nt = (l.car)
          steps[sc_conf_18] = (ind(nt, nts))
          sc_i_17 = (ind(nt, nts))
          predictors[sc_i_17] = (new sc_Pair(sc_conf_18, (predictors[sc_i_17])))
          l = (l.cdr)
          ++sc_conf_18
        steps[sc_conf_18] = ((ind(head, nts)) - nb_nts)
        i = (ind(head, nts))
        enders[i] = (new sc_Pair(sc_conf_18, (enders[i])))
        rule_loop (rules.cdr), (sc_conf_18 + (1)), (rule_num + (1))
      else
        def_loop (defs.cdr), conf
    )
    (rule_loop((def.cdr), conf, (1)))
    ) else `undefined`)

  def_loop grammar, (sc_nts_8.length)
  parser_descr = [
    lexer
    sc_nts_8
    sc_starters_5
    sc_enders_4
    sc_predictors_3
    sc_steps_2
    sc_names_1
  ]
  (input) ->
    optrOpnd = undefined
    sc_optrOpnd_20 = undefined
    sc_optrOpnd_21 = undefined
    sc_optrOpnd_22 = undefined
    loop1 = undefined
    BgL_sc_stateza2_23za2 = undefined
    toks = undefined
    BgL_sc_nbzd2nts_24zd2 = undefined
    sc_steps_25 = undefined
    sc_enders_26 = undefined
    state_num = undefined
    BgL_sc_statesza2_27za2 = undefined
    states = undefined
    i = undefined
    conf = undefined
    l = undefined
    tok_nts = undefined
    sc_i_28 = undefined
    sc_i_29 = undefined
    l1 = undefined
    l2 = undefined
    tok = undefined
    tail1129 = undefined
    L1125 = undefined
    goal_enders = undefined
    BgL_sc_statesza2_30za2 = undefined
    BgL_sc_nbzd2nts_31zd2 = undefined
    BgL_sc_nbzd2confs_32zd2 = undefined
    nb_toks = undefined
    goal_starters = undefined
    sc_states_33 = undefined
    BgL_sc_nbzd2confs_34zd2 = undefined
    BgL_sc_nbzd2toks_35zd2 = undefined
    sc_toks_36 = undefined
    falseHead1128 = undefined
    sc_names_37 = undefined
    sc_steps_38 = undefined
    sc_predictors_39 = undefined
    sc_enders_40 = undefined
    sc_starters_41 = undefined
    sc_nts_42 = undefined
    lexer = undefined
    sc_ind_43 = undefined
    make_states = undefined
    BgL_sc_confzd2setzd2getza2_44za2 = undefined
    conf_set_merge_new_bang = undefined
    conf_set_adjoin = undefined
    BgL_sc_confzd2setzd2adjoinza2_45za2 = undefined
    BgL_sc_confzd2setzd2adjoinza2za2_46z00 = undefined
    conf_set_union = undefined
    forw = undefined
    is_parsed = undefined
    deriv_trees = undefined
    BgL_sc_derivzd2treesza2_47z70 = undefined
    nb_deriv_trees = undefined
    BgL_sc_nbzd2derivzd2treesza2_48za2 = undefined
    sc_ind_43 = (nt, sc_nts_49) ->
      i = undefined
      i = ((sc_nts_49.length) - (1))
      loop
        if i >= (0)
          if sc_isEqual((sc_nts_49[i]), nt)
            return i
          else
            --i
        else
          return false
      return

    make_states = (BgL_sc_nbzd2toks_50zd2, BgL_sc_nbzd2confs_51zd2) ->
      v = undefined
      i = undefined
      sc_states_52 = undefined
      sc_states_52 = (sc_makeVector((BgL_sc_nbzd2toks_50zd2 + (1)), false))
      i = BgL_sc_nbzd2toks_50zd2
      while (i >= (0))
        v = (sc_makeVector((BgL_sc_nbzd2confs_51zd2 + (1)), false))
        v[(0)] = (-1)
        sc_states_52[i] = v
        --i
      sc_states_52

    BgL_sc_confzd2setzd2getza2_44za2 = (state, BgL_sc_statezd2num_53zd2, sc_conf_54) ->
      conf_set = undefined
      BgL_sc_confzd2set_55zd2 = undefined
      (BgL_sc_confzd2set_55zd2 = (state[(sc_conf_54 + (1))]))
      ((if (BgL_sc_confzd2set_55zd2 isnt false) then BgL_sc_confzd2set_55zd2 else ((conf_set = (sc_makeVector((BgL_sc_statezd2num_53zd2 + (6)), false)))
      (conf_set[(1)] = (-3))
      (conf_set[(2)] = (-1))
      (conf_set[(3)] = (-1))
      (conf_set[(4)] = (-1))
      (state[(sc_conf_54 + (1))] = conf_set)
      conf_set
      )))

    conf_set_merge_new_bang = (conf_set) ->
      (conf_set[((conf_set[(1)]) + (5))] = (conf_set[(4)]))
      (conf_set[(1)] = (conf_set[(3)]))
      (conf_set[(3)] = (-1))
      (conf_set[(4)] = (-1))

    conf_set_adjoin = (state, conf_set, sc_conf_56, i) ->
      tail = undefined
      (tail = (conf_set[(3)]))
      (conf_set[(i + (5))] = (-1))
      (conf_set[(tail + (5))] = i)
      (conf_set[(3)] = i)
      ((if (tail < (0)) then ((conf_set[(0)] = (state[(0)]))
      (state[(0)] = sc_conf_56)
      ) else `undefined`))

    BgL_sc_confzd2setzd2adjoinza2_45za2 = (sc_states_57, BgL_sc_statezd2num_58zd2, l, i) ->
      conf_set = undefined
      sc_conf_59 = undefined
      l1 = undefined
      state = undefined
      state = (sc_states_57[BgL_sc_statezd2num_58zd2])
      l1 = l
      while (l1 instanceof sc_Pair)
        sc_conf_59 = (l1.car)
        conf_set = (BgL_sc_confzd2setzd2getza2_44za2(state, BgL_sc_statezd2num_58zd2, sc_conf_59))
        if (conf_set[(i + (5))]) is false
          conf_set_adjoin state, conf_set, sc_conf_59, i
          l1 = (l1.cdr)
        else
          l1 = (l1.cdr)
      `undefined`

    BgL_sc_confzd2setzd2adjoinza2za2_46z00 = (sc_states_60, BgL_sc_statesza2_61za2, BgL_sc_statezd2num_62zd2, sc_conf_63, i) ->
      BgL_sc_confzd2setza2_64z70 = undefined
      BgL_sc_stateza2_65za2 = undefined
      conf_set = undefined
      state = undefined
      (state = (sc_states_60[BgL_sc_statezd2num_62zd2]))
      ((if (((conf_set = (state[(sc_conf_63 + (1))]))
      ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
      ) isnt false) then ((BgL_sc_stateza2_65za2 = (BgL_sc_statesza2_61za2[BgL_sc_statezd2num_62zd2]))
      (BgL_sc_confzd2setza2_64z70 = (BgL_sc_confzd2setzd2getza2_44za2(BgL_sc_stateza2_65za2, BgL_sc_statezd2num_62zd2, sc_conf_63)))
      ((if ((BgL_sc_confzd2setza2_64z70[(i + (5))]) is false) then (conf_set_adjoin(BgL_sc_stateza2_65za2, BgL_sc_confzd2setza2_64z70, sc_conf_63, i)) else `undefined`))
      true
      ) else false))

    conf_set_union = (state, conf_set, sc_conf_66, other_set) ->
      i = undefined
      i = (other_set[(2)])
      while (i >= (0))
        if (conf_set[(i + (5))]) is false
          conf_set_adjoin state, conf_set, sc_conf_66, i
          i = (other_set[(i + (5))])
        else
          i = (other_set[(i + (5))])
      `undefined`

    forw = (sc_states_67, BgL_sc_statezd2num_68zd2, sc_starters_69, sc_enders_70, sc_predictors_71, sc_steps_72, sc_nts_73) ->
      next_set = undefined
      next = undefined
      conf_set = undefined
      ender = undefined
      l = undefined
      starter_set = undefined
      starter = undefined
      sc_l_74 = undefined
      sc_loop1_75 = undefined
      head = undefined
      BgL_sc_confzd2set_76zd2 = undefined
      BgL_sc_statezd2num_77zd2 = undefined
      state = undefined
      sc_states_78 = undefined
      preds = undefined
      BgL_sc_confzd2set_79zd2 = undefined
      step = undefined
      sc_conf_80 = undefined
      BgL_sc_nbzd2nts_81zd2 = undefined
      sc_state_82 = undefined
      sc_state_82 = (sc_states_67[BgL_sc_statezd2num_68zd2])
      BgL_sc_nbzd2nts_81zd2 = (sc_nts_73.length)
      loop
        sc_conf_80 = (sc_state_82[(0)])
        if sc_conf_80 >= (0)
          step = (sc_steps_72[sc_conf_80])
          BgL_sc_confzd2set_79zd2 = (sc_state_82[(sc_conf_80 + (1))])
          head = (BgL_sc_confzd2set_79zd2[(4)])
          sc_state_82[(0)] = (BgL_sc_confzd2set_79zd2[(0)])
          conf_set_merge_new_bang BgL_sc_confzd2set_79zd2
          if step >= (0)
            sc_l_74 = (sc_starters_69[step])
            while (sc_l_74 instanceof sc_Pair)
              starter = (sc_l_74.car)
              starter_set = (BgL_sc_confzd2setzd2getza2_44za2(sc_state_82, BgL_sc_statezd2num_68zd2, starter))
              if (starter_set[(BgL_sc_statezd2num_68zd2 + (5))]) is false
                conf_set_adjoin sc_state_82, starter_set, starter, BgL_sc_statezd2num_68zd2
                sc_l_74 = (sc_l_74.cdr)
              else
                sc_l_74 = (sc_l_74.cdr)
            l = (sc_enders_70[step])
            while (l instanceof sc_Pair)
              ender = (l.car)
              if ((conf_set = (sc_state_82[(ender + (1))]))
              ((if (conf_set isnt false) then (conf_set[(BgL_sc_statezd2num_68zd2 + (5))]) else false))
              ) isnt false
                next = (sc_conf_80 + (1))
                next_set = (BgL_sc_confzd2setzd2getza2_44za2(sc_state_82, BgL_sc_statezd2num_68zd2, next))
                conf_set_union sc_state_82, next_set, next, BgL_sc_confzd2set_79zd2
                l = (l.cdr)
              else
                l = (l.cdr)
          else
            preds = (sc_predictors_71[(step + BgL_sc_nbzd2nts_81zd2)])
            sc_states_78 = sc_states_67
            state = sc_state_82
            BgL_sc_statezd2num_77zd2 = BgL_sc_statezd2num_68zd2
            BgL_sc_confzd2set_76zd2 = BgL_sc_confzd2set_79zd2
            sc_loop1_75 = (l) ->
              sc_state_83 = undefined
              BgL_sc_nextzd2set_84zd2 = undefined
              sc_next_85 = undefined
              pred_set = undefined
              i = undefined
              pred = undefined
              if l instanceof sc_Pair
                pred = (l.car)
                i = head
                while (i >= (0))
                  pred_set = ((sc_state_83 = (sc_states_78[i]))
                  (sc_state_83[(pred + (1))])
                  )
                  if pred_set isnt false
                    sc_next_85 = (pred + (1))
                    BgL_sc_nextzd2set_84zd2 = (BgL_sc_confzd2setzd2getza2_44za2(state, BgL_sc_statezd2num_77zd2, sc_next_85))
                    conf_set_union state, BgL_sc_nextzd2set_84zd2, sc_next_85, pred_set
                  i = (BgL_sc_confzd2set_76zd2[(i + (5))])
                sc_loop1_75 (l.cdr)
              else
                `undefined`

            sc_loop1_75 preds
        else
          return `undefined`
      return

    is_parsed = (nt, i, j, sc_nts_86, sc_enders_87, sc_states_88) ->
      conf_set = undefined
      state = undefined
      sc_conf_89 = undefined
      l = undefined
      BgL_sc_ntza2_90za2 = undefined
      BgL_sc_ntza2_90za2 = (sc_ind_43(nt, sc_nts_86))
      if BgL_sc_ntza2_90za2 isnt false
        sc_nts_86.length
        l = (sc_enders_87[BgL_sc_ntza2_90za2])
        loop
          if l instanceof sc_Pair
            sc_conf_89 = (l.car)
            if ((state = (sc_states_88[j]))
            (conf_set = (state[(sc_conf_89 + (1))]))
            ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
            ) isnt false
              return true
            else
              l = (l.cdr)
          else
            return false
      else
        false
      return

    deriv_trees = (sc_conf_91, i, j, sc_enders_92, sc_steps_93, sc_names_94, sc_toks_95, sc_states_96, BgL_sc_nbzd2nts_97zd2) ->
      sc_loop1_98 = undefined
      prev = undefined
      name = undefined
      (name = (sc_names_94[sc_conf_91]))
      ((if (name isnt false) then ((if (sc_conf_91 < BgL_sc_nbzd2nts_97zd2) then (sc_list((sc_list(name, ((sc_toks_95[i]).car))))) else (sc_list((sc_list(name)))))) else ((prev = (sc_conf_91 - (1)))
      (sc_loop1_98 = (l1, l2) ->
        loop2 = undefined
        ender_set = undefined
        state = undefined
        ender = undefined
        l1 = undefined
        l2 = undefined
        loop
          if l1 instanceof sc_Pair
            ender = (l1.car)
            ender_set = ((state = (sc_states_96[j]))
            (state[(ender + (1))])
            )
            if ender_set isnt false
              loop2 = (k, l2) ->
                loop3 = undefined
                ender_trees = undefined
                prev_trees = undefined
                conf_set = undefined
                sc_state_99 = undefined
                k = undefined
                l2 = undefined
                loop
                  if k >= (0)
                    if (k >= i) and (((sc_state_99 = (sc_states_96[k]))
                    (conf_set = (sc_state_99[(prev + (1))]))
                    ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
                    ) isnt false)
                      prev_trees = (deriv_trees(prev, i, k, sc_enders_92, sc_steps_93, sc_names_94, sc_toks_95, sc_states_96, BgL_sc_nbzd2nts_97zd2))
                      ender_trees = (deriv_trees(ender, k, j, sc_enders_92, sc_steps_93, sc_names_94, sc_toks_95, sc_states_96, BgL_sc_nbzd2nts_97zd2))
                      loop3 = (l3, l2) ->
                        l4 = undefined
                        sc_l2_100 = undefined
                        ender_tree = undefined
                        if l3 instanceof sc_Pair
                          ender_tree = (sc_list((l3.car)))
                          l4 = prev_trees
                          sc_l2_100 = l2
                          while (l4 instanceof sc_Pair)
                            sc_l2_100 = (new sc_Pair((sc_append((l4.car), ender_tree)), sc_l2_100))
                            l4 = (l4.cdr)
                          loop3 (l3.cdr), sc_l2_100
                        else
                          loop2 (ender_set[(k + (5))]), l2

                      return (loop3(ender_trees, l2))
                    else
                      k = (ender_set[(k + (5))])
                  else
                    return (sc_loop1_98((l1.cdr), l2))
                return

              return (loop2((ender_set[(2)]), l2))
            else
              l1 = (l1.cdr)
          else
            return l2
        return
      )
      (sc_loop1_98((sc_enders_92[(sc_steps_93[prev])]), null))
      )))

    BgL_sc_derivzd2treesza2_47z70 = (nt, i, j, sc_nts_101, sc_enders_102, sc_steps_103, sc_names_104, sc_toks_105, sc_states_106) ->
      conf_set = undefined
      state = undefined
      sc_conf_107 = undefined
      l = undefined
      trees = undefined
      BgL_sc_nbzd2nts_108zd2 = undefined
      BgL_sc_ntza2_109za2 = undefined
      BgL_sc_ntza2_109za2 = (sc_ind_43(nt, sc_nts_101))
      if BgL_sc_ntza2_109za2 isnt false
        BgL_sc_nbzd2nts_108zd2 = (sc_nts_101.length)
        l = (sc_enders_102[BgL_sc_ntza2_109za2])
        trees = null
        while (l instanceof sc_Pair)
          sc_conf_107 = (l.car)
          if ((state = (sc_states_106[j]))
          (conf_set = (state[(sc_conf_107 + (1))]))
          ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
          ) isnt false
            l = (l.cdr)
            trees = (sc_append((deriv_trees(sc_conf_107, i, j, sc_enders_102, sc_steps_103, sc_names_104, sc_toks_105, sc_states_106, BgL_sc_nbzd2nts_108zd2)), trees))
          else
            l = (l.cdr)
        trees
      else
        false

    nb_deriv_trees = (sc_conf_110, i, j, sc_enders_111, sc_steps_112, sc_toks_113, sc_states_114, BgL_sc_nbzd2nts_115zd2) ->
      sc_loop1_116 = undefined
      tmp1124 = undefined
      prev = undefined
      (prev = (sc_conf_110 - (1)))
      ((if (((tmp1124 = (sc_conf_110 < BgL_sc_nbzd2nts_115zd2))
      ((if (tmp1124 isnt false) then tmp1124 else ((sc_steps_112[prev]) < (0))))
      ) isnt false) then (1) else ((sc_loop1_116 = (l, sc_n_118) ->
        nb_ender_trees = undefined
        nb_prev_trees = undefined
        conf_set = undefined
        state = undefined
        k = undefined
        n = undefined
        ender_set = undefined
        sc_state_117 = undefined
        ender = undefined
        l = undefined
        sc_n_118 = undefined
        loop
          if l instanceof sc_Pair
            ender = (l.car)
            ender_set = ((sc_state_117 = (sc_states_114[j]))
            (sc_state_117[(ender + (1))])
            )
            if ender_set isnt false
              k = (ender_set[(2)])
              n = sc_n_118
              while (k >= (0))
                if (k >= i) and (((state = (sc_states_114[k]))
                (conf_set = (state[(prev + (1))]))
                ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
                ) isnt false)
                  nb_prev_trees = (nb_deriv_trees(prev, i, k, sc_enders_111, sc_steps_112, sc_toks_113, sc_states_114, BgL_sc_nbzd2nts_115zd2))
                  nb_ender_trees = (nb_deriv_trees(ender, k, j, sc_enders_111, sc_steps_112, sc_toks_113, sc_states_114, BgL_sc_nbzd2nts_115zd2))
                  k = (ender_set[(k + (5))])
                  n += (nb_prev_trees * nb_ender_trees)
                else
                  k = (ender_set[(k + (5))])
              return (sc_loop1_116((l.cdr), n))
            else
              l = (l.cdr)
          else
            return sc_n_118
        return
      )
      (sc_loop1_116((sc_enders_111[(sc_steps_112[prev])]), (0)))
      )))

    BgL_sc_nbzd2derivzd2treesza2_48za2 = (nt, i, j, sc_nts_119, sc_enders_120, sc_steps_121, sc_toks_122, sc_states_123) ->
      conf_set = undefined
      state = undefined
      sc_conf_124 = undefined
      l = undefined
      nb_trees = undefined
      BgL_sc_nbzd2nts_125zd2 = undefined
      BgL_sc_ntza2_126za2 = undefined
      BgL_sc_ntza2_126za2 = (sc_ind_43(nt, sc_nts_119))
      if BgL_sc_ntza2_126za2 isnt false
        BgL_sc_nbzd2nts_125zd2 = (sc_nts_119.length)
        l = (sc_enders_120[BgL_sc_ntza2_126za2])
        nb_trees = (0)
        while (l instanceof sc_Pair)
          sc_conf_124 = (l.car)
          if ((state = (sc_states_123[j]))
          (conf_set = (state[(sc_conf_124 + (1))]))
          ((if (conf_set isnt false) then (conf_set[(i + (5))]) else false))
          ) isnt false
            l = (l.cdr)
            nb_trees = ((nb_deriv_trees(sc_conf_124, i, j, sc_enders_120, sc_steps_121, sc_toks_122, sc_states_123, BgL_sc_nbzd2nts_125zd2)) + nb_trees)
          else
            l = (l.cdr)
        nb_trees
      else
        false

    lexer = (parser_descr[(0)])
    sc_nts_42 = (parser_descr[(1)])
    sc_starters_41 = (parser_descr[(2)])
    sc_enders_40 = (parser_descr[(3)])
    sc_predictors_39 = (parser_descr[(4)])
    sc_steps_38 = (parser_descr[(5)])
    sc_names_37 = (parser_descr[(6)])
    falseHead1128 = (new sc_Pair(null, null))
    L1125 = (lexer(input))
    tail1129 = falseHead1128
    until (L1125 is null)
      tok = (L1125.car)
      l1 = (tok.cdr)
      l2 = null
      while (l1 instanceof sc_Pair)
        sc_i_29 = (sc_ind_43((l1.car), sc_nts_42))
        if sc_i_29 isnt false
          l1 = (l1.cdr)
          l2 = (new sc_Pair(sc_i_29, l2))
        else
          l1 = (l1.cdr)
      sc_optrOpnd_22 = (new sc_Pair((tok.car), (sc_reverse(l2))))
      sc_optrOpnd_21 = (new sc_Pair(sc_optrOpnd_22, null))
      tail1129.cdr = sc_optrOpnd_21
      tail1129 = (tail1129.cdr)
      L1125 = (L1125.cdr)
    sc_optrOpnd_20 = (falseHead1128.cdr)
    sc_toks_36 = (sc_list2vector(sc_optrOpnd_20))
    BgL_sc_nbzd2toks_35zd2 = (sc_toks_36.length)
    BgL_sc_nbzd2confs_34zd2 = (sc_steps_38.length)
    sc_states_33 = (make_states(BgL_sc_nbzd2toks_35zd2, BgL_sc_nbzd2confs_34zd2))
    goal_starters = (sc_starters_41[(0)])
    BgL_sc_confzd2setzd2adjoinza2_45za2 sc_states_33, (0), goal_starters, (0)
    forw sc_states_33, (0), sc_starters_41, sc_enders_40, sc_predictors_39, sc_steps_38, sc_nts_42
    sc_i_28 = (0)
    while (sc_i_28 < BgL_sc_nbzd2toks_35zd2)
      tok_nts = ((sc_toks_36[sc_i_28]).cdr)
      BgL_sc_confzd2setzd2adjoinza2_45za2 sc_states_33, (sc_i_28 + (1)), tok_nts, sc_i_28
      forw sc_states_33, (sc_i_28 + (1)), sc_starters_41, sc_enders_40, sc_predictors_39, sc_steps_38, sc_nts_42
      ++sc_i_28
    nb_toks = (sc_toks_36.length)
    BgL_sc_nbzd2confs_32zd2 = (sc_steps_38.length)
    BgL_sc_nbzd2nts_31zd2 = (sc_nts_42.length)
    BgL_sc_statesza2_30za2 = (make_states(nb_toks, BgL_sc_nbzd2confs_32zd2))
    goal_enders = (sc_enders_40[(0)])
    l = goal_enders
    while (l instanceof sc_Pair)
      conf = (l.car)
      BgL_sc_confzd2setzd2adjoinza2za2_46z00 sc_states_33, BgL_sc_statesza2_30za2, nb_toks, conf, (0)
      l = (l.cdr)
    i = nb_toks
    while (i >= (0))
      states = sc_states_33
      BgL_sc_statesza2_27za2 = BgL_sc_statesza2_30za2
      state_num = i
      sc_enders_26 = sc_enders_40
      sc_steps_25 = sc_steps_38
      BgL_sc_nbzd2nts_24zd2 = BgL_sc_nbzd2nts_31zd2
      toks = sc_toks_36
      BgL_sc_stateza2_23za2 = (BgL_sc_statesza2_30za2[i])
      loop1 = ->
        sc_loop1_127 = undefined
        prev = undefined
        BgL_sc_statesza2_128za2 = undefined
        sc_states_129 = undefined
        j = undefined
        i = undefined
        sc_i_130 = undefined
        head = undefined
        conf_set = undefined
        sc_conf_131 = undefined
        sc_conf_131 = (BgL_sc_stateza2_23za2[(0)])
        if sc_conf_131 >= (0)
          conf_set = (BgL_sc_stateza2_23za2[(sc_conf_131 + (1))])
          head = (conf_set[(4)])
          BgL_sc_stateza2_23za2[(0)] = (conf_set[(0)])
          conf_set_merge_new_bang conf_set
          sc_i_130 = head
          while (sc_i_130 >= (0))
            i = sc_i_130
            j = state_num
            sc_states_129 = states
            BgL_sc_statesza2_128za2 = BgL_sc_statesza2_27za2
            prev = (sc_conf_131 - (1))
            if (sc_conf_131 >= BgL_sc_nbzd2nts_24zd2) and ((sc_steps_25[prev]) >= (0))
              sc_loop1_127 = (l) ->
                k = undefined
                ender_set = undefined
                state = undefined
                ender = undefined
                l = undefined
                loop
                  if l instanceof sc_Pair
                    ender = (l.car)
                    ender_set = ((state = (sc_states_129[j]))
                    (state[(ender + (1))])
                    )
                    if ender_set isnt false
                      k = (ender_set[(2)])
                      while (k >= (0))
                        BgL_sc_confzd2setzd2adjoinza2za2_46z00 sc_states_129, BgL_sc_statesza2_128za2, j, ender, k  if (BgL_sc_confzd2setzd2adjoinza2za2_46z00(sc_states_129, BgL_sc_statesza2_128za2, k, prev, i)) isnt false  if k >= i
                        k = (ender_set[(k + (5))])
                      return (sc_loop1_127((l.cdr)))
                    else
                      l = (l.cdr)
                  else
                    return `undefined`
                return

              sc_loop1_127 (sc_enders_26[(sc_steps_25[prev])])
            sc_i_130 = (conf_set[(sc_i_130 + (5))])
          loop1()
        else
          `undefined`

      loop1()
      --i
    optrOpnd = BgL_sc_statesza2_30za2
    [
      sc_nts_42
      sc_starters_41
      sc_enders_40
      sc_predictors_39
      sc_steps_38
      sc_names_37
      sc_toks_36
      optrOpnd
      is_parsed
      BgL_sc_derivzd2treesza2_47z70
      BgL_sc_nbzd2derivzd2treesza2_48za2
    ]

BgL_parsezd2ze3parsedzf3zc2 = (parse, nt, i, j) ->
  is_parsed = undefined
  states = undefined
  enders = undefined
  nts = undefined
  (nts = (parse[(0)]))
  (enders = (parse[(2)]))
  (states = (parse[(7)]))
  (is_parsed = (parse[(8)]))
  (is_parsed(nt, i, j, nts, enders, states))

BgL_parsezd2ze3treesz31 = (parse, nt, i, j) ->
  BgL_sc_derivzd2treesza2_132z70 = undefined
  states = undefined
  toks = undefined
  names = undefined
  steps = undefined
  enders = undefined
  nts = undefined
  (nts = (parse[(0)]))
  (enders = (parse[(2)]))
  (steps = (parse[(4)]))
  (names = (parse[(5)]))
  (toks = (parse[(6)]))
  (states = (parse[(7)]))
  (BgL_sc_derivzd2treesza2_132z70 = (parse[(9)]))
  (BgL_sc_derivzd2treesza2_132z70(nt, i, j, nts, enders, steps, names, toks, states))

BgL_parsezd2ze3nbzd2treesze3 = (parse, nt, i, j) ->
  BgL_sc_nbzd2derivzd2treesza2_133za2 = undefined
  states = undefined
  toks = undefined
  steps = undefined
  enders = undefined
  nts = undefined
  (nts = (parse[(0)]))
  (enders = (parse[(2)]))
  (steps = (parse[(4)]))
  (toks = (parse[(6)]))
  (states = (parse[(7)]))
  (BgL_sc_nbzd2derivzd2treesza2_133za2 = (parse[(10)]))
  (BgL_sc_nbzd2derivzd2treesza2_133za2(nt, i, j, nts, enders, steps, toks, states))

test = (k) ->
  x = undefined
  p = undefined
  (p = (BgL_makezd2parserzd2(const_earley, (l) ->
    sc_x_134 = undefined
    tail1134 = undefined
    L1130 = undefined
    falseHead1133 = undefined
    falseHead1133 = (new sc_Pair(null, null))
    tail1134 = falseHead1133
    L1130 = l
    until (L1130 is null)
      tail1134.cdr = (new sc_Pair(((sc_x_134 = (L1130.car))
      (sc_list(sc_x_134, sc_x_134))
      ), null))
      tail1134 = (tail1134.cdr)
      L1130 = (L1130.cdr)
    falseHead1133.cdr
  )))
  (x = (p((sc_vector2list((sc_makeVector(k, "a")))))))
  (sc_length((BgL_parsezd2ze3treesz31(x, "s", (0), k))))

BgL_earleyzd2benchmarkzd2 = ->
  args = null
  sc_tmp = arguments.length - 1

  while sc_tmp >= 0
    args = sc_cons(arguments[sc_tmp], args)
    sc_tmp--
  k = undefined
  (k = ((if (args is null) then (7) else (args.car))))
  (BgL_runzd2benchmarkzd2("earley", (1), ->
    test k
  , (result) ->
    (sc_display(result))
    (sc_newline())
    result is 132
  ))

SC_DEFAULT_OUT = new sc_GenericOutputPort((s) ->
)
SC_ERROR_OUT = SC_DEFAULT_OUT
BgL_runzd2benchmarkzd2 = RunBenchmark
